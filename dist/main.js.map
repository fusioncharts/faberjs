{"version":3,"sources":["webpack://Mason/webpack/universalModuleDefinition","webpack://Mason/webpack/bootstrap","webpack://Mason/./src/utils/constants.js","webpack://Mason/./src/utils/index.js","webpack://Mason/./src/grid/track-sizing.js","webpack://Mason/./src/grid/index.js","webpack://Mason/./src/grid/helpers/repeatResolver.js","webpack://Mason/./src/mason.js","webpack://Mason/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ATOMIC_DATA_TYPE","getDisplayProperty","domTree","style","display","pluckNumber","arg","arguments","length","isNaN","Number","getMultiplierOfFr","size","replace","TrackResolver","tracks","undefined","items","containerSize","_classCallCheck","this","clear","set","info","props","_initTrackSize","_initItems","_tracks","len","type","multiplier","baseSize","growthLimit","config","_config","trackAr","frTracks","intrinsicTracks","Array","isArray","indexOf","Infinity","push","Math","max","min","_objectSpread","sanitizedTracks","_items","nonSpanningItemStartIndex","item","sanitizedItems","validItems","start","end","autoFlow","_getParentSize","sort","a","b","gap1","gap2","widthOfParentTracks","filter","track","forEach","_placeNonSpanningItems","_placeSpanningItems","_distributeFreeSpace","trackIndex","_this$_config","slice","sizeConsumed","sizeLeft","sizePerTrack","availableTracks","hasFrTrack","_this$_config2","spanningItems","trackSizedp","_this$_config3","totalSpaceUsed","trackId","index","_frSpaceDistributorHelper","spacePerFrTrack","eligibleTracks","totalFrTrackRatio","freeSpace","spacePerIntrinsicTrack","minMaxTracks","frozenTrack","frozen","_intrinsicSpaceDistributorHelper","validSizes","minmaxRegex","getUCFirstString","str","charAt","toUpperCase","validNestedGrid","tree","_ref","gridTemplateColumns","gridTemplateRows","test","parseRepeatFunction","repeatStr","split","map","trim","getCleanSize","sizeAr","getItemSize","dimension","templateCol","parsedDim","trackDir","updateMatrix","grid","j","x","y","getMaxRowColumn","maxRow","maxColumn","gridColumnStart","gridColumnEnd","gridRowStart","gridRowEnd","Grid","grid_classCallCheck","setup","_tsa","mapping","_domTree","_sanitizeTracks","_sanitizeItems","_inflateTracks","_assignCoordinatesToCells","trackInfo","_getMaxRowColumn","children","_fetchTrackInformation","row","nameToLineMap","lineToNameMap","rowTracks","col","colTracks","nameList","sizeList","startLineNames","endLineNames","splittedTrackInfo","toLowerCase","getProps","itemStyle","cell","extraRows","gridAutoFlow","rowNum","keys","colNum","autoFlowItems","gridMatrix","freeCells","grid_objectSpread","rowStart","rowEnd","colStart","colEnd","shift","ceil","sizedTracks","minHeightContribution","minWidthContribution","_ref2","paddingStart","paddingEnd","paddingTop","paddingBottom","width","height","tsa","resolveTracks","calculatedStyle","_solveUnresolvedChildren","resolvedTracks","trackWidth","parsedWidthOfItem","childrenWithRepeatConfiguration","unResolvedChildren","child","parentReference","colTrackDp","parentInfo","numOfRows","rowWidth","itemInARow","newGridTemplateColumns","newGridTemplateRows","itemWidth","repeatResolver","gridLayoutEngine","trackHeight","_domTree$style","justifyItems","alignItems","rowTrackdp","colTrackdp","layout","justifySelf","alignSelf","padding","x2","y2","replaceWithAbsValue","styleTrack","calculatedTrack","trackSplitAr","trackWithAbsValue","counter","updateDomTreeWithResolvedValues","rowTrackSum","colTrackSum","containerStyle","getConfig","userGivenStyles","computeGridLayout","count","compute","LayoutEngine","mason_classCallCheck","computeLayout","mason","clonedDomTree","cloneObject","_typeof","arr","cloneObj","attachLayoutInformation","baseTree","calculatedTree","__webpack_exports__","mason_computeLayout"],"mappings":"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","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Mason\"] = factory();\n\telse\n\t\troot[\"Mason\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const DISPLAY_GRID = 'grid';\nexport const DISPLAY_FLEX = 'flex';\nexport const CENTER = 'center';\nexport const START = 'start';\nexport const END = 'end';\nexport const STRETCH = 'stretch';\nexport const ATOMIC_DATA_TYPE = ['string', 'number', 'function', 'boolean', 'undefined'];","import { ATOMIC_DATA_TYPE } from \"./constants\";\n\nlet UNDEF;\n\nconst getDisplayProperty = (domTree) => {\n    return domTree.style && domTree.style.display;\n  },\n  cloneObject = (arg) => {\n    if ((ATOMIC_DATA_TYPE.indexOf(typeof arg) > -1) || arg === null) {\n      return arg;\n    }\n\n    if (Array.isArray(arg)) {\n      let i,\n        len,\n        arr = [];\n\n      for (i = 0, len = arg.length; i < len; i++) {\n        arr.push(cloneObject(arg[i]));\n      }\n\n      return arr;\n    } else if (typeof arg === 'object') {\n      let cloneObj = {},\n        key;\n\n      for (key in arg) {\n        cloneObj[key] = cloneObject(arg[key]);\n      }\n\n      return cloneObj;\n    }\n  },\n  attachLayoutInformation = (baseTree = {}, calculatedTree = {}) => {\n    let i,\n      len;\n\n    baseTree.layout = calculatedTree.layout;\n\n    for (i = 0, len = (baseTree.children || []).length; i < len; i++) {\n      attachLayoutInformation(baseTree.children[i], calculatedTree.children[i]);\n    }\n  },\n  pluckNumber = function () {\n    var arg,\n      i,\n      l;\n\n    for (i = 0, l = arguments.length; i < l; i += 1) {\n      arg = arguments[i];\n      if (!arg && arg !== false && arg !== 0) {\n        continue;\n      } else if (isNaN(arg = Number(arg))) {\n        continue;\n      }\n      return arg;\n    }\n    return UNDEF;\n  };\n\nexport {\n  cloneObject,\n  attachLayoutInformation,\n  getDisplayProperty,\n  pluckNumber\n};","const getMultiplierOfFr = size => +size.replace(/fr/, ''),\n  _frSpaceDistributorHelper = (tracks, totalSpaceUsed, containerSize) => {\n    let freeSpace,\n      spacePerFrTrack,\n      eligibleTracks,\n      totalFrTrackRatio = 0;\n      \n    if (!tracks.length) {\n      return;\n    }\n\n    tracks.forEach(track => totalFrTrackRatio += track.multiplier);\n\n    freeSpace = containerSize - totalSpaceUsed;\n    spacePerFrTrack = freeSpace / totalFrTrackRatio;\n    \n    eligibleTracks = tracks.filter(track => track.baseSize <= track.multiplier * spacePerFrTrack);\n\n    if (eligibleTracks.length < tracks.length) {\n      tracks.filter(track => track.baseSize > track.multiplier * spacePerFrTrack).forEach(track => totalSpaceUsed += track.baseSize);\n      return _frSpaceDistributorHelper(eligibleTracks, totalSpaceUsed, containerSize);\n    } else {\n      eligibleTracks.forEach(track => track.baseSize = track.multiplier * spacePerFrTrack);\n    }\n  },\n  _intrinsicSpaceDistributorHelper = (tracks, totalSpaceUsed, containerSize) => {\n    let freeSpace,\n      spacePerIntrinsicTrack,\n      i,\n      len,\n      frozenTrack = 0,\n      minMaxTracks,\n      growthLimit,\n      baseSize;\n      \n    if (!tracks.length) {\n      return;\n    }\n    minMaxTracks = tracks.filter(track => track.type === 'minmax' && track.growthLimit !== Infinity);\n    freeSpace = containerSize - totalSpaceUsed;\n    \n    minMaxTracks.sort(function (a, b) {\n      let gap1 = a.growthLimit - a.baseSize,\n        gap2 = b.growthLimit - b.baseSize;\n      \n      return gap1 - gap2;\n    });\n    \n    len = minMaxTracks.length;\n    while (frozenTrack < len && freeSpace) {\n      spacePerIntrinsicTrack = freeSpace / ((minMaxTracks.length - frozenTrack) || 1);\n      /**\n       * @todo: remove the frozen tracks.\n       */\n      for (i = 0, len = minMaxTracks.length; i <  len; i++) {\n        growthLimit = minMaxTracks[i].growthLimit;\n        \n        baseSize = Math.min(spacePerIntrinsicTrack + minMaxTracks[i].baseSize, growthLimit);\n        freeSpace -= (baseSize - minMaxTracks[i].baseSize);\n        minMaxTracks[i].baseSize = baseSize;\n\n        if (growthLimit === baseSize && !minMaxTracks[i].frozen) {\n          minMaxTracks[i].frozen = true;\n          frozenTrack++;\n        }\n      }\n    }\n\n    tracks = tracks.filter(track => (track.type === 'minmax' && track.growthLimit === Infinity) || track.type !== 'minmax');\n    spacePerIntrinsicTrack = freeSpace / tracks.length;\n\n    tracks.forEach(track => track.baseSize += spacePerIntrinsicTrack);\n  };\n\nclass TrackResolver {\n  constructor (tracks = [], items = [], containerSize = 600) {\n    this.clear();\n\n    this.set('tracks', tracks);\n    this.set('items', items);\n    this.set('containerSize', containerSize);\n    return this;\n  }\n\n  set (key, info) {\n    this.props[key] = info;\n\n    switch (key) {\n    case 'tracks':\n      this._initTrackSize(); break;\n    case 'items':\n      this._initItems(); break;\n    case 'containerSize': \n      this.props[key] = isNaN(+info) ? 0 : +info;\n    }\n    return this;\n  }\n\n  get (key) {\n    return this.props[key];\n  }\n\n  _initTrackSize (_tracks) {\n    let tracks = _tracks || this.props.tracks || [],\n      config = this._config,\n      trackAr = [{}],\n      i,\n      len,\n      size,\n      type,\n      multiplier,\n      baseSize,\n      growthLimit;\n\n    config.frTracks = [];\n    config.intrinsicTracks = [];\n\n    for (i = 1, len = tracks.length; i < len; i++) {\n      size = tracks[i].size;\n\n      multiplier = 1;\n      if (Array.isArray(size)) {\n        baseSize = +size[0] || 0;\n\n        if (size[1].indexOf('fr') > 0 || size[0].indexOf('fr') > 0) {\n          growthLimit = Infinity;\n          config.frTracks.push(i);\n          type = 'minmax';\n        } else if (size[1] === 'auto' || size[0] === 'auto') {\n          growthLimit = Infinity;\n          config.intrinsicTracks.push(i);\n          type = 'minmax';\n        } else if (!isNaN(+size[0]) && !isNaN(+size[1])) {\n          growthLimit = Math.max(+size[0], +size[1]);\n          baseSize = Math.min(+size[0], +size[1]);\n          config.intrinsicTracks.push(i);\n          type = 'minmax';\n        }\n      } else if (!isNaN(+size)) {\n        baseSize = growthLimit = +size;\n        type = 'fixed';\n      } else if (size.indexOf('fr') > 0) {\n        baseSize = 0;\n        growthLimit = Infinity;\n        config.frTracks.push(i);\n        type = 'flex';\n        multiplier = getMultiplierOfFr(size);\n      } else {\n        baseSize = 0;\n        growthLimit = Infinity;\n        type = 'intrinsic';\n        config.intrinsicTracks.push(i);\n      }\n\n      trackAr.push({\n        ...tracks[i],\n        type,\n        multiplier,\n        baseSize,\n        growthLimit\n      });\n    }\n\n    return (config.sanitizedTracks = trackAr);\n  }\n\n  _initItems (_items) {\n    let items = _items || this.props.items || [],\n      config = this._config,\n      sanitizedItems = [],\n      nonSpanningItemStartIndex,\n      item,\n      validItems = 0,\n      i,\n      len;\n\n    for (i = 0, len = items.length; i < len; i++) {\n      if (isNaN(items[i].start) || isNaN(items[i].end)) {\n        config.autoFlow.push(items[i]);\n        continue;\n      }\n      sanitizedItems.push({...items[i]});\n      \n      item = sanitizedItems[validItems];\n      validItems++;\n\n      item.size = isNaN(item.size) ? this._getParentSize(item) : +item.size;\n    }\n\n    sanitizedItems.sort(function (a, b) {\n      let gap1 = a.end - a.start,\n        gap2 = b.end - b.start;\n\n      if (gap1 === gap2) {\n        return a.start - b.start;\n      } else return gap1 - gap2;\n    });\n\n    for (i = 0, nonSpanningItemStartIndex = len = sanitizedItems.length; i < len; i++) {\n      if (sanitizedItems[i].end - sanitizedItems[i].start > 1) {\n        nonSpanningItemStartIndex = i;\n        break;\n      }\n    }\n\n    this._config.nonSpanningItemStartIndex = nonSpanningItemStartIndex;\n\n    return (this._config.sanitizedItems = sanitizedItems);\n  }\n\n  _getParentSize (item) {\n    let { sanitizedTracks } = this._config,\n      parentTracks,\n      widthOfParentTracks = 0;\n\n    parentTracks = sanitizedTracks.filter(track => (track.start >= item.start && track.end <= item.end));\n\n    parentTracks.forEach(track => widthOfParentTracks += track.baseSize);\n\n    return (widthOfParentTracks || 0);\n  }\n\n  resolveTracks () {\n    this._placeNonSpanningItems()\n      ._placeSpanningItems()\n      ._distributeFreeSpace();\n\n    return this._config.sanitizedTracks;\n  }\n\n  _placeNonSpanningItems () {\n    let { sanitizedItems, sanitizedTracks, nonSpanningItemStartIndex } = this._config,\n      nonSpanningItems = sanitizedItems.slice(0, nonSpanningItemStartIndex),\n      track,\n      trackIndex;\n\n    nonSpanningItems.forEach(item => {\n      trackIndex = item.start;\n      track = sanitizedTracks[trackIndex];\n\n      if (track.type !== 'fixed') {\n        track.baseSize = Math.max(track.baseSize, item.size);\n        track.growthLimit = Math.max(track.growthLimit, track.baseSize);\n      }\n    });\n\n    return this;\n  }\n\n  _placeSpanningItems () {\n    let { sanitizedItems, sanitizedTracks, nonSpanningItemStartIndex, frTracks } = this._config,\n      spanningItems = sanitizedItems.slice(nonSpanningItemStartIndex),\n      trackSizedp = [0],\n      sizeConsumed,\n      sizeLeft,\n      sizePerTrack,\n      availableTracks,\n      hasFrTrack,\n      i,\n      len;\n\n    if (!spanningItems.length) return this;\n\n    for (i = 1, len = sanitizedTracks.length; i < len; i++) {\n      trackSizedp[i] = trackSizedp[i - 1] + (sanitizedTracks[i].baseSize || 0);\n    }\n\n    spanningItems.forEach(item => {\n      sizeConsumed = trackSizedp[item.end - 1] - trackSizedp[item.start - 1];\n      sizeLeft = Math.max(0, item.size - sizeConsumed);\n\n      if (!sizeLeft) return;\n\n      for (i = item.start, hasFrTrack = false, availableTracks = 0; i < item.end; i++) {\n        if (frTracks.indexOf(i) >= 0) {\n          hasFrTrack = true;\n        }\n        if (sanitizedTracks[i].type !== 'fixed') {\n          availableTracks++;\n        }\n      }\n\n      if (!availableTracks || hasFrTrack) return;\n\n      sizePerTrack = sizeLeft / availableTracks;\n      for (i = item.start; i < item.end; i++) {\n        if (sanitizedTracks[i].type !== 'fixed') {\n          sanitizedTracks[i].baseSize += sizePerTrack;\n        }\n      }\n    });\n    return this;\n  }\n\n  _distributeFreeSpace () {\n    let { frTracks, intrinsicTracks, sanitizedTracks } = this._config,\n      { containerSize } = this.props,\n      totalSpaceUsed = 0;\n\n    sanitizedTracks.forEach(track => totalSpaceUsed += (track.baseSize || 0));\n\n    if (totalSpaceUsed < containerSize) {\n      if (frTracks.length) {\n        frTracks.forEach((trackId, index) => {frTracks[index] = sanitizedTracks[trackId];});\n        frTracks.forEach(track => totalSpaceUsed -= track.baseSize);\n        _frSpaceDistributorHelper(frTracks, totalSpaceUsed, containerSize);\n      } else if (intrinsicTracks.length) {\n        intrinsicTracks.forEach((trackId, index) => {intrinsicTracks[index] = sanitizedTracks[trackId];});\n        _intrinsicSpaceDistributorHelper(intrinsicTracks, totalSpaceUsed, containerSize);\n      }\n    }\n    return this;\n  }\n\n  clear () {\n    this.props = {};\n    this._config = {\n      frTracks: [],\n      intrinsicTracks: [],\n      autoFlow: []\n    };\n\n    return this;\n  }\n}\n\nexport default TrackResolver;\n","import { getDisplayProperty, pluckNumber } from \"../utils\";\nimport TrackResolver from \"./track-sizing\";\nimport { CENTER, END, STRETCH } from \"../utils/constants\";\nimport { repeatResolver } from \"./helpers/repeatResolver\";\n\nconst validSizes = ['auto', 'none'],\n  minmaxRegex = /minmax/,\n  // repeatFunctionRegex = /repeat\\(/g,\n  // templateSplitRegex = /\\s(\\[.*\\])*(\\(.*\\))*/g,\n  templateSplitRegex = ' ',\n  getUCFirstString = str => (str.charAt(0).toUpperCase() + str.slice(1)),\n  validNestedGrid = tree => {\n    let { gridTemplateColumns, gridTemplateRows } = tree.style || {};\n\n    if (/repeat\\(/g.test(gridTemplateColumns) || /repeat\\(/g.test(gridTemplateRows)) {\n      return false;\n    }\n    return true;\n  },\n  parseRepeatFunction = repeatStr => {\n    return repeatStr.split(/\\(|\\)/g)[1].split(',').map(arg => arg && arg.trim());\n  },\n  getCleanSize = size => {\n    size = size.trim();\n    if (size === 'auto') return size;\n    if (!isNaN(+size)) return +size;\n\n    if (minmaxRegex.test(size)) {\n      let sizeAr = size.split(/\\(|\\)/g)[1].split(',');\n\n      return [\n        sizeAr[0].trim(),\n        sizeAr[1].trim()\n      ];\n    }\n\n    return size;\n  },\n  getItemSize = (items, dimension) => {\n    let filteredItems,\n      templateCol,\n      parsedDim = getUCFirstString(dimension),\n      size,\n      trackDir = dimension === 'width' ? 'col' : 'row';\n\n    filteredItems = items.map(item => {\n      templateCol = item.style['gridTemplate' + getUCFirstString(trackDir === 'col' ? 'columns' : 'rows')];\n      if (getDisplayProperty(item) === 'grid' && /repeat\\(/g.test(templateCol)) {\n        size = parseRepeatFunction(templateCol)[1];\n      } else {\n        size = item.style['min' + parsedDim + 'Contribution'] || item.style[dimension] || 'auto';\n      }\n\n      return {\n        start: item[trackDir + 'Start'],\n        end: item[trackDir + 'End'],\n        size\n      };\n    });\n    return filteredItems;\n  },\n  updateMatrix = (grid, start, end) => {\n    let i,\n      j;\n\n    for (i = start.x; i < end.x; i++) {\n      for (j = start.y; j < end.y; j++) {\n        grid[i][j] = true;\n      }\n    }\n  },\n  getMaxRowColumn = (items) =>{\n    let maxRow = 1, maxColumn = 1;\n    items.forEach((item) => {\n      maxColumn = Math.max(isNaN(item.style.gridColumnStart) ? 0 : item.style.gridColumnStart, maxColumn, isNaN(item.style.gridColumnEnd * 1 - 1) ? 0 : item.style.gridColumnEnd*1 - 1);\n      maxRow = Math.max(isNaN(item.style.gridRowStart) ? 0 : item.style.gridRowStart, maxRow, isNaN(item.style.gridRowEnd * 1 - 1) ? 0 : item.style.gridRowEnd*1 - 1);\n    });\n    return {\n      maxRow,\n      maxColumn\n    };\n  };\nclass Grid {\n  /**\n   * Creates an instance of Grid. Initializes the props and _config object.\n   * @memberof Grid\n   */\n  constructor () {\n    this.setup();\n  }\n\n  /**\n   * Initializes _config, props objects. Also initializes and stores a new instance of TrackResolver.\n   *\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  setup () {\n    this._tsa = new TrackResolver();\n    this.props = {};\n    this._config = {\n      mapping: {}\n    };\n\n    return this;\n  }\n\n  /**\n   * Setter method to set props.\n   *\n   * @param   {string} key\n   *          key represents the name by which the value is to be stored in props object.\n   * @param   {any} value\n   *          value is the information(can be anything) that has to be stored against the key.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  set (key, value) {\n    this.props[key] = value;\n\n    return this;\n  }\n\n  /**\n   * Getter method to fetch props.\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  getProps (key) {\n    return this.props[key];\n  }\n\n  /**\n   * Getter method to fetch config.\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  getConfig (key) {\n    return this._config[key];\n  }\n\n  /**\n   * compute method is called to calculate the layout. This is the driver API.\n   * 1. Tracks(rows and columns) are sanitized. Sanitization of tracks consists of going through the child nodes to get an overall estimate\n   *    regarding the number of tracks that are required.\n   * 2. Items(child nodes) are sanitized. Any item without any proper gridStart and gridEnd values gets sanitized here.\n   * 3. Track solving algrithm is run for both columns and rows to calculate the size each track will get.\n   * 4. Once tracks are resolved and all tracks have their size, all the grid items are assigned their width, height, x and y(when applicable)\n   *\n   * @param {Object} _domTree\n   *        Full node tree consisting of grid container and grid items.\n   * @memberof Grid\n   */\n  compute (_domTree) {\n    let domTree = _domTree || this.props.domTree;\n\n    this._sanitizeTracks(domTree)\n      ._sanitizeItems(domTree)\n      ._inflateTracks()\n      ._assignCoordinatesToCells(domTree);\n  }\n\n  /**\n   * Rows and columns are refered as tracks in css-grid terminology.\n   * Track sanitization is required to account for any changes in the number of tracks by considering the grid items.\n   * Items are iterated to check if all the times can be accomodated within the user-defined grid cells. If not, tracks will\n   * be increased.\n   *\n   * @param   {Object} [_domTree={}]\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _sanitizeTracks (_domTree = {}) {\n    let style = _domTree.style,\n      { gridTemplateRows, gridTemplateColumns } = style,\n      config = this._config,\n      trackInfo;\n\n    let {maxColumn, maxRow} = getMaxRowColumn(_domTree.children);\n    this.set(\"maxTracks\", maxRow);\n\n    trackInfo = this._fetchTrackInformation(gridTemplateRows);\n    config.mapping.row = {\n      nameToLineMap: trackInfo.nameToLineMap,\n      lineToNameMap: trackInfo.lineToNameMap\n    };\n    config.rowTracks = trackInfo.tracks;\n\n    this.set(\"maxTracks\", maxColumn);\n    trackInfo = this._fetchTrackInformation(gridTemplateColumns);\n    config.mapping.col = {\n      nameToLineMap: trackInfo.nameToLineMap,\n      lineToNameMap: trackInfo.lineToNameMap\n    };\n    config.colTracks = trackInfo.tracks;\n\n    return this;\n  }\n\n  /**\n   * Any track is bounded by two lines, which are called grid lines. A grid line can have multiple names.\n   * To make calculations more easier, a map is maintained between line names and line numbers. \n   *\n   * @param   {string} [tracks='none'] \n   *          gridTemplateRows or gridTemplateColumns(user provided values)\n   * @returns {Object}\n   *          tracks: Array of tracks where track has it's start, end and size(provided by user) specified\n   *          nameToLineMap: Object where key is the name and the value is the line number\n   *          lineToNameMap: Object where key is the number and the value is the name\n   * @memberof Grid\n   */\n  _fetchTrackInformation (tracks = 'none') {\n    let i,\n      len,\n      splittedTrackInfo = tracks.split(templateSplitRegex),\n      nameList,\n      sizeList,\n      sanitizedTracks = [{}],\n      startLineNames,\n      endLineNames,\n      nameToLineMap = {},\n      lineToNameMap = {};\n\n    nameList = splittedTrackInfo.filter(track => {\n      if (track && typeof track === 'string' && track.length) {\n        len = track.length;\n        if (track[0] === '[' && track[len - 1] === ']') {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n\n    sizeList = splittedTrackInfo.filter(size => {\n      if (!size) return false;\n\n      len = (size + '').toLowerCase().replace(/px|fr/, '');\n      if (validSizes.indexOf(len) >= 0 || minmaxRegex.test(len) || !isNaN(len)) {\n        return true;\n      }\n      return false;\n    }).map(size => getCleanSize(size));\n\n    len = sizeList.length;\n    if(tracks === \"none\"){\n      len = this.getProps(\"maxTracks\");\n    }\n\n    for (i = 0; i < len; i++) {\n      startLineNames = (nameList[i] && nameList[i].replace(/\\[|\\]/g, '').split(' ').filter(name => name.length).map(name => name.trim())) || [i + 1 + ''];\n      endLineNames = (nameList[i + 1] && nameList[i + 1].replace(/\\[|\\]/g, '').split(' ').filter(name => name.length).map(name => name.trim())) || [i + 2 + ''];\n\n      sanitizedTracks.push({\n        start: i + 1,\n        end: i + 2,\n        size: sizeList[i] || 'auto'\n      });\n\n      // A line can have multiple names but a name can only be assigned to a single line\n      lineToNameMap[i + 1] = startLineNames;\n      lineToNameMap[i + 2] = endLineNames;\n      startLineNames.forEach(name => nameToLineMap[name] = i + 1);\n      endLineNames.forEach(name => nameToLineMap[name] = i + 2);\n      nameToLineMap[i + 1] = i + 1;\n      nameToLineMap[i + 2] = i + 2;\n    }\n\n    return {\n      tracks: sanitizedTracks,\n      nameToLineMap,\n      lineToNameMap\n    };\n  }\n\n  /**\n   * Sanitization of grid items. The gridRowStart and gridColumnStart values are replaced by the line numbers. Also,\n   * if any item do not have any gridRowStart and/or gridColumnEnd values mentioned, they are placed accordingly in\n   * empty cells in rowwise or columnwise manner, based on the value of gridAutoFlow.\n   *\n   * @param   {Object} _domTree\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _sanitizeItems (_domTree) {\n    let domTree = (_domTree || this.props.domTree),\n      items = domTree.children || [],\n      mapping = this._config.mapping,\n      gridAutoFlow = domTree.style.gridAutoFlow || 'row',\n      rowNum = Object.keys(mapping.row.lineToNameMap).length,\n      colNum = Object.keys(mapping.col.lineToNameMap).length,\n      sanitizedItems = [],\n      autoFlowItems = [],\n      itemStyle,\n      gridMatrix = [[]],\n      freeCells = [],\n      cell,\n      item,\n      extraRows,\n      i,\n      j,\n      len;\n\n    for (i = 1; i <= rowNum; i++) {\n      gridMatrix.push([]);\n    }\n    for (i = 0, len = items.length; i < len; i++) {\n      itemStyle = items[i].style;\n\n      sanitizedItems.push({\n        ...items[i],\n        rowStart: mapping.row.nameToLineMap[itemStyle.gridRowStart],\n        rowEnd: mapping.row.nameToLineMap[itemStyle.gridRowEnd],\n        colStart: mapping.col.nameToLineMap[itemStyle.gridColumnStart],\n        colEnd: mapping.col.nameToLineMap[itemStyle.gridColumnEnd]\n      });\n      item = sanitizedItems[i];\n      updateMatrix(gridMatrix, {x: item.colStart, y: item.rowStart}, {x: item.colEnd, y: item.rowEnd});\n    }\n\n    autoFlowItems = sanitizedItems.filter(item => (!item.colStart || !item.rowStart));\n\n    /**\n     * @todo: Scope to improve code here.\n     */\n    if (autoFlowItems) {\n      if (gridAutoFlow === 'row') {\n        for (i = 1; i < rowNum; i++) {\n          for (j = 1; j < colNum; j++) {\n            if (!gridMatrix[i][j]) {\n              freeCells.push({row: i, col: j});\n            }\n          }\n        }\n\n        while (autoFlowItems.length && freeCells.length) {\n          item = autoFlowItems.shift();\n          cell = freeCells.shift();\n\n          item.rowStart = cell.row;\n          item.colStart = cell.col;\n          item.rowEnd = cell.row + 1;\n          item.colEnd = cell.col + 1;\n        }\n\n        extraRows = Math.ceil(autoFlowItems.length / colNum);\n        if (extraRows) {\n          while (extraRows--) {\n            domTree.style.gridTemplateRows += 'auto ';\n            mapping.row.nameToLineMap[rowNum + 1] = rowNum + 1;\n            mapping.row.nameToLineMap[rowNum + 2] = rowNum + 2;\n            rowNum++;\n            gridMatrix.push([]);\n          }\n          domTree.style.gridTemplateRows = domTree.style.gridTemplateRows.trim();\n\n          freeCells = [];\n          for (i = 1; i <= rowNum; i++) {\n            for (j = 1; j <= colNum; j++) {\n              if (!gridMatrix[i][j]) {\n                freeCells.push({row: i, col: j});\n              }\n            }\n          }\n          while (autoFlowItems.length) {\n            item = autoFlowItems.shift();\n            cell = freeCells.shift();\n\n            item.rowStart = cell.row;\n            item.colStart = cell.col;\n            item.rowEnd = cell.row + 1;\n            item.colEnd = cell.col + 1;\n          }\n        }\n      }\n    }\n\n    this._config.sanitizedItems = sanitizedItems;\n    return this;\n  }\n\n  /**\n   * Track solving algorithm is used to calculate the size of each track. First the column tracks are resolved, then the\n   * row tracks. For track solving algorithm to run, it is important to resolve all the nested grids. Solving the nested\n   * grids allows to consider their min-content contribution while solving tracks of parent grid.\n   * \n   * An exception arises if a nested grid has repeat in either of the gridTemplateColumns or gridTemplateRows property.\n   * In that case, the nested grid is solved once the column tracks of the parent grid is solved.\n   *\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _inflateTracks () {\n    let { sanitizedItems, colTracks, rowTracks } = this._config,\n      sizedTracks,\n      minHeightContribution = 0,\n      minWidthContribution = 0,\n      { domTree } = this.props,\n      { paddingStart, paddingEnd, paddingTop, paddingBottom, width, height } = domTree.style || {},\n      tsa = new TrackResolver();\n\n    if (!isNaN(+width)) {\n      width -= (paddingStart + paddingEnd);\n    }\n    sizedTracks = tsa.clear()\n      .set('tracks', colTracks)\n      .set('items', getItemSize(sanitizedItems, 'width'))\n      .set('containerSize', width || 'auto')\n      .resolveTracks();\n\n    colTracks.forEach((track, index) => {\n      track.calculatedStyle = sizedTracks[index];\n      minWidthContribution += sizedTracks[index].baseSize || 0;\n    });\n\n    this._solveUnresolvedChildren();\n\n    if (!isNaN(+height)) {\n      height -= (paddingTop + paddingBottom);\n    }\n    sizedTracks = tsa.clear()\n      .set('tracks', rowTracks)\n      .set('items', getItemSize(sanitizedItems, 'height'))\n      .set('containerSize', height || 'auto')\n      .resolveTracks();\n\n    rowTracks.forEach((track, index) => {\n      track.calculatedStyle = sizedTracks[index];\n      minHeightContribution += sizedTracks[index].baseSize || 0;\n    });\n\n    domTree.style.minHeightContribution = minHeightContribution;\n    domTree.style.minWidthContribution = minWidthContribution;\n    return this;\n  }\n\n  /**\n   * The grid items which are also grid containers(nested grids) and has repeat() configuration in either of\n   * gridTenplateColumns or gridTemplateRows attribute are solved after the column tracks of the parents are solved.\n   *\n   * @param   {Object} _domTree\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _solveUnresolvedChildren (_domTree) {\n    let domTree = _domTree || this.props.domTree,\n      childrenWithRepeatConfiguration = (domTree.unResolvedChildren || []).filter(child => /repeat\\(/g.test(child.style.gridTemplateColumns)\n      || /repeat\\(/g.test(child.style.gridTemplateRows)),\n      { colTracks, mapping } = this._config,\n      parentReference = this.getProps('parent'),\n      colTrackDp = [0],\n      resolvedTracks,\n      i,\n      len,\n      trackWidth,\n      parentInfo,\n      parsedWidthOfItem,\n      colStart,\n      colEnd;\n\n    if (!childrenWithRepeatConfiguration.length) {\n      return this;\n    }\n\n    for (i = 1, len = colTracks.length; i < len; i++) {\n      colTrackDp[i] = colTrackDp[i - 1] + colTracks[i].calculatedStyle.baseSize;\n    }\n\n    childrenWithRepeatConfiguration.forEach(child => {\n      // if (repeatFunctionRegex.test(child.style.gridTemplateColumns)) {\n      parsedWidthOfItem = parseRepeatFunction(child.style.gridTemplateColumns)[1];\n      colStart = mapping.col.nameToLineMap[child.style.gridColumnStart];\n      colEnd = mapping.col.nameToLineMap[child.style.gridColumnEnd];\n\n      trackWidth = colTrackDp[colEnd - 1 ] - colTrackDp[colStart - 1];\n      parentInfo = {\n        itemWidth: parsedWidthOfItem,\n        width: trackWidth\n      };\n\n      resolvedTracks = repeatResolver(child, parentInfo);\n\n      child.style.gridTemplateColumns = resolvedTracks.gridTemplateColumns;\n      child.style.gridTemplateRows = resolvedTracks.gridTemplateRows;\n\n      parentReference.gridLayoutEngine(child);\n      // }\n    });\n\n    return this;\n  }\n\n  /**\n   * After the grid is resolved, the items and the container should receive their dimensions(width, height) and positions(x, y).\n   * This values are calculated after considering the justifyItem and alignItem attributes.\n   *\n   * @param {Object} _domTree\n   * @memberof Grid\n   */\n  _assignCoordinatesToCells (_domTree) {\n    let domTree = _domTree || this.props.domTree,\n      { sanitizedItems, rowTracks, colTracks } = this._config,\n      item,\n      len,\n      i,\n      { justifyItems, alignItems, paddingStart, paddingTop } = domTree.style,\n      trackWidth,\n      trackHeight,\n      width,\n      height,\n      x,\n      y,\n      rowTrackdp = [paddingStart],\n      colTrackdp = [paddingTop];\n\n    for (i = 1, len = rowTracks.length; i < len; i++) {\n      rowTrackdp[i] = rowTrackdp[i - 1] + rowTracks[i].calculatedStyle.baseSize;\n    }\n\n    for (i = 1, len = colTracks.length; i < len; i++) {\n      colTrackdp[i] = colTrackdp[i - 1] + colTracks[i].calculatedStyle.baseSize;\n    }\n    domTree.layout = {\n      x: 0,\n      y: 0,\n      width: isNaN(domTree.style.width) ? colTrackdp[colTrackdp.length - 1] : domTree.style.width,\n      height: isNaN(domTree.style.height) ? rowTrackdp[rowTrackdp.length - 1] : domTree.style.height\n    };\n    (domTree.children || []).forEach((child, index) => {\n      item = sanitizedItems[index];\n      trackWidth = colTrackdp[item.colEnd - 1] - colTrackdp[item.colStart - 1];\n      trackHeight = rowTrackdp[item.rowEnd - 1] - rowTrackdp[item.rowStart - 1];\n\n      width = isNaN(+child.style.width) ? trackWidth : +child.style.width;\n      height = isNaN(+child.style.height) ? trackHeight : +child.style.height;\n\n      switch (justifyItems || child.style.justifySelf) {\n      case CENTER:\n        x = colTrackdp[item.colStart - 1] + (trackWidth / 2) - (width / 2); break;\n      case END:\n        x = colTrackdp[item.colEnd - 1] - width; break;\n      case STRETCH:\n        width = trackWidth;\n        x = colTrackdp[item.colStart - 1]; break;\n      default:\n        x = colTrackdp[item.colStart - 1];\n      }\n\n      switch (alignItems || child.style.alignSelf) {\n      case CENTER:\n        y = rowTrackdp[item.rowStart - 1] + (trackHeight / 2) - (height / 2); break;\n      case END:\n        y = rowTrackdp[item.rowEnd - 1] - height; break;\n      case STRETCH:\n        height = trackHeight;\n        y = rowTrackdp[item.rowStart - 1]; break;\n      default:\n        y = rowTrackdp[item.rowStart - 1];\n      }\n\n      x += pluckNumber(item.style.paddingStart, item.style.padding, 0);\n      y += pluckNumber(item.style.paddingTop, item.style.padding, 0);\n\n      child.layout = {\n        x,\n        y,\n        x2: x + width,\n        y2: y + height,\n        width,\n        height\n      };\n    });\n\n    return this;\n  }\n}\n\nconst replaceWithAbsValue = (styleTrack = '', calculatedTrack) => {\n    let trackSplitAr = styleTrack.split(templateSplitRegex).filter(track => track && !!track.trim()),\n      trackWithAbsValue = '',\n      counter = 1;\n\n    if (trackSplitAr.length && !(/repeat\\(/.test(styleTrack))) {\n      trackSplitAr.forEach(track => {\n        if (validSizes.indexOf(track) > -1 || /[0-9]fr/.test(track) || minmaxRegex.test(track) || !isNaN(track)) {\n          trackWithAbsValue += calculatedTrack[counter].calculatedStyle.baseSize + ' ';\n          counter++;\n        } else {\n          trackWithAbsValue += track + ' ';\n        }\n      });\n    } else {\n      calculatedTrack.forEach(track => {\n        if (isNaN(track.calculatedStyle.baseSize)) return;\n\n        trackWithAbsValue += (track.calculatedStyle.baseSize + ' ');\n      });\n    }\n\n    return trackWithAbsValue.trim();\n  },\n  updateDomTreeWithResolvedValues = (domTree, grid) => {\n    let containerStyle = domTree.style,\n      rowTracks = grid.getConfig('rowTracks'),\n      colTracks = grid.getConfig('colTracks'),\n      mapping = grid.getConfig('mapping'),\n      { gridTemplateRows, gridTemplateColumns } = containerStyle,\n      child,\n      i,\n      j,\n      len,\n      rowTrackSum,\n      colTrackSum,\n      rowStart,\n      rowEnd,\n      colStart,\n      colEnd;\n\n    domTree.style.gridTemplateRows = replaceWithAbsValue(gridTemplateRows, rowTracks);\n    domTree.style.gridTemplateColumns = replaceWithAbsValue(gridTemplateColumns, colTracks);\n\n    for (i = 0, len = (domTree.children || []).length; i < len; i++) {\n      child = domTree.children[i];\n      if (getDisplayProperty(child)) {\n        child.style.gridTemplateColumns = child.userGivenStyles.gridTemplateColumns;\n        child.style.gridTemplateRows = child.userGivenStyles.gridTemplateRows;\n        if (isNaN(child.userGivenStyles.width)) {\n          colStart = child.style.gridColumnStart;\n          colEnd = child.style.gridColumnEnd;\n\n          colStart = mapping.col.nameToLineMap[colStart];\n          colEnd = mapping.col.nameToLineMap[colEnd];\n\n          for (j = colStart, colTrackSum = 0; j < colEnd; j++) {\n            colTrackSum += colTracks[j].calculatedStyle.baseSize;\n          }\n          child.style.width = colTrackSum;\n        }\n        if (isNaN(child.userGivenStyles.height)) {\n          rowStart = child.style.gridRowStart;\n          rowEnd = child.style.gridRowEnd;\n\n          rowStart = mapping.row.nameToLineMap[rowStart];\n          rowEnd = mapping.row.nameToLineMap[rowEnd];\n\n          for (j = rowStart, rowTrackSum = 0; j < rowEnd; j++) {\n            rowTrackSum += rowTracks[j].calculatedStyle.baseSize;\n          }\n          child.style.height = rowTrackSum;\n        }\n      }\n    }\n\n    return domTree;\n  };\n\nfunction computeGridLayout (domTree, count = 1) {\n  let i,\n    len,\n    style = domTree.style,\n    child,\n    grid;\n\n  if (!domTree || !domTree.style) {\n    return;\n  }\n\n  if (!domTree.userGivenStyles) {\n    domTree.style.width = isNaN(domTree.style.width) ? 'auto' : domTree.style.width;\n    domTree.style.height = isNaN(domTree.style.height) ? 'auto' : domTree.style.height;\n\n    style.paddingStart = pluckNumber(style.paddingStart, style.padding, 0);\n    style.paddingEnd = pluckNumber(style.paddingEnd, style.padding, 0);\n    style.paddingTop = pluckNumber(style.paddingTop, style.padding, 0);\n    style.paddingBottom = pluckNumber(style.paddingBottom, style.padding, 0);\n\n    domTree.userGivenStyles = {\n      gridTemplateColumns: domTree.style.gridTemplateColumns,\n      gridTemplateRows: domTree.style.gridTemplateRows,\n      width: domTree.style.width,\n      height: domTree.style.height\n    };\n  }\n\n  domTree.unResolvedChildren = [];\n  for (i = 0, len = (domTree.children && domTree.children.length); i < len; i++) {\n    child = domTree.children[i];\n    if (getDisplayProperty(child)) {\n      if (validNestedGrid(child)) {\n        this.compute(child);\n      } else {\n        domTree.unResolvedChildren.push(child);\n      }\n    }\n  }\n\n  grid = new Grid();\n  grid.set('domTree', domTree)\n    .set('parent', this)\n    .compute();\n\n  if (count < 2) {\n    this.gridLayoutEngine(updateDomTreeWithResolvedValues(domTree, grid), 2);\n  }\n\n  return domTree;\n}\n\nexport {\n  computeGridLayout\n};\n","function repeatResolver (domTree, parentInfo) {\n  let { children } = domTree,\n    rowWidth = 0,\n    numOfRows,\n    itemInARow = 0,\n    // itemWidth,\n    repeatStyle = 'auto-fit',\n    newGridTemplateColumns = '',\n    newGridTemplateRows = '',\n    i,\n    len,\n    height = 0,\n    { itemWidth, width } = parentInfo;\n\n  width = isNaN(+width) ? 0 : +width;\n\n  children.forEach(child => (height = Math.max(height, +child.style.height || 0)));\n  // [repeatStyle, itemWidth] = parseRepeatFunction(gridTemplateColumns);\n  itemWidth = +itemWidth;\n\n  if (repeatStyle === 'auto-fit') {\n    rowWidth += itemWidth;\n    newGridTemplateColumns += (itemWidth + ' ');\n    itemInARow = 1;\n    for (i = 1, len = children.length; i < len; i++) {\n      if (rowWidth + itemWidth > width) {\n        break;\n      }\n      rowWidth += itemWidth;\n      newGridTemplateColumns += (itemWidth + ' ');\n    }\n\n    itemInARow = i;\n    numOfRows = Math.ceil(len / itemInARow);\n\n    while (numOfRows--) {\n      newGridTemplateRows += height + ' ';\n    }\n  }\n\n  return {\n    gridTemplateColumns: newGridTemplateColumns.trim(),\n    gridTemplateRows: newGridTemplateRows.trim()\n  };\n}\n\nexport {\n  repeatResolver\n};\n","import { getDisplayProperty, cloneObject, attachLayoutInformation } from \"./utils\";\nimport { DISPLAY_GRID, DISPLAY_FLEX } from \"./utils/constants\";\nimport { computeGridLayout } from \"./grid\";\n\nclass LayoutEngine {\n  constructor () {\n    this.gridLayoutEngine = computeGridLayout;\n  }\n\n  compute (domTree) {\n    switch (getDisplayProperty(domTree)) {\n    \n    case DISPLAY_GRID: return this.gridLayoutEngine(domTree);\n    case DISPLAY_FLEX: return this.gridLayoutEngine(domTree);\n    default:\n      // Probably throw unsupported error?\n      return this.gridLayoutEngine(domTree);\n\n    }\n  }\n}\n\n/**\n * Public API used externally to provide input to layout engine\n * \n * @param {Object} domTree Object containing the layout node information\n */\nconst computeLayout = (domTree) => {\n  const mason = new LayoutEngine();\n  let clonedDomTree = cloneObject(domTree),\n    calculatedTree;\n\n  clonedDomTree.root = true;\n  calculatedTree = mason.compute(clonedDomTree);\n  attachLayoutInformation(domTree, calculatedTree);\n\n  return domTree;\n};\n\nexport {\n  computeLayout\n};\n","import { computeLayout } from './mason';\n\nexport {\n  computeLayout\n};\n"],"sourceRoot":""}