{"version":3,"sources":["webpack://faber/webpack/universalModuleDefinition","webpack://faber/webpack/bootstrap","webpack://faber/./src/utils/constants.js","webpack://faber/./src/utils/index.js","webpack://faber/./src/grid/track-sizing.js","webpack://faber/./src/grid/index.js","webpack://faber/./src/grid/helpers/repeatResolver.js","webpack://faber/./src/faber.js","webpack://faber/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ATOMIC_DATA_TYPE","getDisplayProperty","domTree","style","display","pluckNumber","arg","arguments","length","isNaN","Number","getMultiplierOfFr","size","replace","TrackResolver","tracks","items","containerSize","this","clear","set","info","props","_initTrackSize","_initItems","_tracks","len","type","multiplier","baseSize","growthLimit","config","_config","trackAr","frTracks","intrinsicTracks","Array","isArray","indexOf","Infinity","push","Math","max","min","sanitizedTracks","_items","nonSpanningItemStartIndex","item","sanitizedItems","validItems","start","end","autoFlow","_getParentSize","sort","a","b","gap1","gap2","widthOfParentTracks","filter","track","forEach","_placeNonSpanningItems","_placeSpanningItems","_distributeFreeSpace","trackIndex","slice","sizeConsumed","sizeLeft","sizePerTrack","availableTracks","hasFrTrack","spanningItems","trackSizedp","totalSpaceUsed","trackId","index","_frSpaceDistributorHelper","spacePerFrTrack","eligibleTracks","totalFrTrackRatio","freeSpace","spacePerIntrinsicTrack","minMaxTracks","frozenTrack","frozen","_intrinsicSpaceDistributorHelper","validSizes","minmaxRegex","getUCFirstString","str","charAt","toUpperCase","validNestedGrid","tree","gridTemplateColumns","gridTemplateRows","test","parseRepeatFunction","repeatStr","split","map","trim","getCleanSize","sizeAr","getItemSize","dimension","templateCol","parsedDim","trackDir","updateMatrix","grid","j","x","y","getMaxRowColumn","maxRow","maxColumn","gridColumnStart","gridColumnEnd","gridRowStart","gridRowEnd","Grid","setup","_tsa","mapping","_domTree","_sanitizeTracks","_sanitizeItems","_inflateTracks","_assignCoordinatesToCells","trackInfo","children","_fetchTrackInformation","row","nameToLineMap","lineToNameMap","rowTracks","col","colTracks","nameList","sizeList","startLineNames","endLineNames","splittedTrackInfo","toLowerCase","getProps","itemStyle","cell","extraRows","gridAutoFlow","rowNum","keys","colNum","autoFlowItems","gridMatrix","freeCells","rowStart","rowEnd","colStart","colEnd","sanitizedItem","shift","ceil","sizedTracks","minHeightContribution","minWidthContribution","paddingStart","paddingEnd","paddingTop","paddingBottom","width","height","tsa","resolveTracks","calculatedStyle","_solveUnresolvedChildren","resolvedTracks","trackWidth","parsedWidthOfItem","childrenWithRepeatConfiguration","unResolvedChildren","child","parentReference","colTrackDp","parentInfo","numOfRows","rowWidth","itemInARow","newGridTemplateColumns","newGridTemplateRows","itemWidth","repeatResolver","gridLayoutEngine","trackHeight","justifyItems","alignItems","rowTrackdp","colTrackdp","layout","justifySelf","alignSelf","padding","x2","y2","replaceWithAbsValue","styleTrack","calculatedTrack","trackSplitAr","trackWithAbsValue","counter","updateDomTreeWithResolvedValues","rowTrackSum","colTrackSum","containerStyle","getConfig","userGivenStyles","computeGridLayout","count","compute","LayoutEngine","computeLayout","faber","clonedDomTree","cloneObject","arr","cloneObj","attachLayoutInformation","baseTree","calculatedTree"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,IARlB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,sCClFrD,IAMEC,EAAmB,CAAC,SAAU,SAAU,WAAY,UAAW,a,qOCFjE,IAAMC,EAAqB,SAACC,GACxB,OAAOA,EAAQC,OAASD,EAAQC,MAAMC,SAsCxCC,EAAc,WACZ,IAAIC,EACFtC,EACAC,EAEF,IAAKD,EAAI,EAAGC,EAAIsC,UAAUC,OAAQxC,EAAIC,EAAGD,GAAK,EAE5C,KADAsC,EAAMC,UAAUvC,MACI,IAARsC,GAAyB,IAARA,KAElBG,MAAMH,EAAMI,OAAOJ,IAG9B,OAAOA,G,61BCvDb,IAAMK,EAAoB,SAAAC,GAAI,OAAKA,EAAKC,QAAQ,KAAM,KAwcvCC,E,WAjXb,aAA2D,IAA9CC,EAA8C,uDAArC,GAAIC,EAAiC,uDAAzB,GAAIC,EAAqB,uDAAL,IAMpD,O,4FANyD,SACzDC,KAAKC,QAELD,KAAKE,IAAI,SAAUL,GACnBG,KAAKE,IAAI,QAASJ,GAClBE,KAAKE,IAAI,gBAAiBH,GACnBC,K,mDAcJ3B,EAAK8B,GAGR,OAFAH,KAAKI,MAAM/B,GAAO8B,EAEV9B,GACR,IAAK,SACH2B,KAAKK,iBAAkB,MACzB,IAAK,QACHL,KAAKM,aAAc,MACrB,IAAK,gBACHN,KAAKI,MAAM/B,GAAOkB,OAAOY,GAAQ,GAAKA,EAExC,OAAOH,O,0BAYJ3B,GACH,OAAO2B,KAAKI,MAAM/B,K,qCA4BJkC,GACd,IAGEzD,EACA0D,EACAd,EACAe,EACAC,EACAC,EACAC,EATEf,EAASU,GAAWP,KAAKI,MAAMP,QAAU,GAC3CgB,EAASb,KAAKc,QACdC,EAAU,CAAC,IAYb,IAHAF,EAAOG,SAAW,GAClBH,EAAOI,gBAAkB,GAEpBnE,EAAI,EAAG0D,EAAMX,EAAOP,OAAQxC,EAAI0D,EAAK1D,IACxC4C,EAAOG,EAAO/C,GAAG4C,KAEjBgB,EAAa,EACTQ,MAAMC,QAAQzB,IAChBiB,GAAYjB,EAAK,IAAM,EAEnBA,EAAK,GAAG0B,QAAQ,MAAQ,GAAK1B,EAAK,GAAG0B,QAAQ,MAAQ,GACvDR,EAAcS,IACdR,EAAOG,SAASM,KAAKxE,GACrB2D,EAAO,UACc,SAAZf,EAAK,IAA6B,SAAZA,EAAK,IACpCkB,EAAcS,IACdR,EAAOI,gBAAgBK,KAAKxE,GAC5B2D,EAAO,UACGlB,OAAOG,EAAK,KAAQH,OAAOG,EAAK,MAC1CkB,EAAcW,KAAKC,KAAK9B,EAAK,IAAKA,EAAK,IACvCiB,EAAWY,KAAKE,KAAK/B,EAAK,IAAKA,EAAK,IACpCmB,EAAOI,gBAAgBK,KAAKxE,GAC5B2D,EAAO,WAEClB,OAAOG,GAGRA,EAAK0B,QAAQ,MAAQ,GAC9BT,EAAW,EACXC,EAAcS,IACdR,EAAOG,SAASM,KAAKxE,GACrB2D,EAAO,OACPC,EAAajB,EAAkBC,KAE/BiB,EAAW,EACXC,EAAcS,IACdZ,EAAO,YACPI,EAAOI,gBAAgBK,KAAKxE,KAZ5B6D,EAAWC,GAAelB,EAC1Be,EAAO,SAcTM,EAAQO,KAAR,KACKzB,EAAO/C,GADZ,CAEE2D,OACAC,aACAC,WACAC,iBAIJ,OAAQC,EAAOa,gBAAkBX,I,iCAavBY,GACV,IAGEC,EACAC,EAEA/E,EACA0D,EAPEV,EAAQ6B,GAAU3B,KAAKI,MAAMN,OAAS,GACxCe,EAASb,KAAKc,QACdgB,EAAiB,GAGjBC,EAAa,EAIf,IAAKjF,EAAI,EAAG0D,EAAMV,EAAMR,OAAQxC,EAAI0D,EAAK1D,IACnCyC,MAAMO,EAAMhD,GAAGkF,QAAUzC,MAAMO,EAAMhD,GAAGmF,KAC1CpB,EAAOqB,SAASZ,KAAKxB,EAAMhD,KAG7BgF,EAAeR,KAAf,KAAwBxB,EAAMhD,KAE9B+E,EAAOC,EAAeC,GACtBA,IAEAF,EAAKnC,KAAOH,MAAMsC,EAAKnC,MAAQM,KAAKmC,eAAeN,IAASA,EAAKnC,MAYnE,IATAoC,EAAeM,MAAK,SAAUC,EAAGC,GAC/B,IAAIC,EAAOF,EAAEJ,IAAMI,EAAEL,MACnBQ,EAAOF,EAAEL,IAAMK,EAAEN,MAEnB,OAAIO,IAASC,EACJH,EAAEL,MAAQM,EAAEN,MACLO,EAAOC,KAGpB1F,EAAI,EAAG8E,EAA4BpB,EAAMsB,EAAexC,OAAQxC,EAAI0D,EAAK1D,IAC5E,GAAIgF,EAAehF,GAAGmF,IAAMH,EAAehF,GAAGkF,MAAQ,EAAG,CACvDJ,EAA4B9E,EAC5B,MAMJ,OAFAkD,KAAKc,QAAQc,0BAA4BA,EAEjC5B,KAAKc,QAAQgB,eAAiBA,I,qCAYxBD,GACV,IAAEH,EAAoB1B,KAAKc,QAAzBY,gBAEJe,EAAsB,EAMxB,OAJef,EAAgBgB,QAAO,SAAAC,GAAK,OAAKA,EAAMX,OAASH,EAAKG,OAASW,EAAMV,KAAOJ,EAAKI,OAElFW,SAAQ,SAAAD,GAAK,OAAKF,GAAuBE,EAAMhC,YAEpD8B,GAAuB,I,sCAwB/B,OAJAzC,KAAK6C,yBACFC,sBACAC,uBAEI/C,KAAKc,QAAQY,kB,+CAWI,IAGtBiB,EACAK,EAJsB,EAC6ChD,KAAKc,QAApEgB,EADkB,EAClBA,eAAgBJ,EADE,EACFA,gBAAiBE,EADf,EACeA,0BAevC,OAdqBE,EAAemB,MAAM,EAAGrB,GAI5BgB,SAAQ,SAAAf,GACvBmB,EAAanB,EAAKG,MAGC,WAFnBW,EAAQjB,EAAgBsB,IAEdvC,OACRkC,EAAMhC,SAAWY,KAAKC,IAAImB,EAAMhC,SAAUkB,EAAKnC,MAC/CiD,EAAM/B,YAAcW,KAAKC,IAAImB,EAAM/B,YAAa+B,EAAMhC,cAInDX,O,4CAYc,IAInBkD,EACAC,EACAC,EACAC,EACAC,EACAxG,EACA0D,EAVmB,EAC0DR,KAAKc,QAA9EgB,EADe,EACfA,eAAgBJ,EADD,EACCA,gBAAiBE,EADlB,EACkBA,0BAA2BZ,EAD7C,EAC6CA,SAChEuC,EAAgBzB,EAAemB,MAAMrB,GACrC4B,EAAc,CAAC,GASjB,IAAKD,EAAcjE,OAAQ,OAAOU,KAElC,IAAKlD,EAAI,EAAG0D,EAAMkB,EAAgBpC,OAAQxC,EAAI0D,EAAK1D,IACjD0G,EAAY1G,GAAK0G,EAAY1G,EAAI,IAAM4E,EAAgB5E,GAAG6D,UAAY,GA2BxE,OAxBA4C,EAAcX,SAAQ,SAAAf,GAIpB,GAHAqB,EAAeM,EAAY3B,EAAKI,IAAM,GAAKuB,EAAY3B,EAAKG,MAAQ,GACpEmB,EAAW5B,KAAKC,IAAI,EAAGK,EAAKnC,KAAOwD,GAEnC,CAEA,IAAKpG,EAAI+E,EAAKG,MAAOsB,GAAa,EAAOD,EAAkB,EAAGvG,EAAI+E,EAAKI,IAAKnF,IACtEkE,EAASI,QAAQtE,IAAM,IACzBwG,GAAa,GAEiB,UAA5B5B,EAAgB5E,GAAG2D,MACrB4C,IAIJ,GAAKA,IAAmBC,EAGxB,IADAF,EAAeD,EAAWE,EACrBvG,EAAI+E,EAAKG,MAAOlF,EAAI+E,EAAKI,IAAKnF,IACD,UAA5B4E,EAAgB5E,GAAG2D,OACrBiB,EAAgB5E,GAAG6D,UAAYyC,OAI9BpD,O,6CAgBe,MAC+BA,KAAKc,QAApDE,EADgB,EAChBA,SAAUC,EADM,EACNA,gBAAiBS,EADX,EACWA,gBAC7B3B,EAAkBC,KAAKI,MAAvBL,cACF0D,EAAiB,EAcnB,OAZA/B,EAAgBkB,SAAQ,SAAAD,GAAK,OAAKc,GAAmBd,EAAMhC,UAAY,KAEnE8C,EAAiB1D,IACfiB,EAAS1B,QACX0B,EAAS4B,SAAQ,SAACc,EAASC,GAAY3C,EAAS2C,GAASjC,EAAgBgC,MACzE1C,EAAS4B,SAAQ,SAAAD,GAAK,OAAKc,GAAkBd,EAAMhC,YAta7B,SAA5BiD,EAA6B/D,EAAQ4D,EAAgB1D,GACnD,IACE8D,EACAC,EACAC,EAAoB,EAEtB,GAAKlE,EAAOP,OAAZ,CAWA,GAPAO,EAAO+C,SAAQ,SAAAD,GAAK,OAAKoB,GAAqBpB,EAAMjC,cAGpDmD,GADY9D,EAAgB0D,GACEM,GAE9BD,EAAiBjE,EAAO6C,QAAO,SAAAC,GAAK,OAAIA,EAAMhC,UAAYgC,EAAMjC,WAAamD,MAE1DvE,OAASO,EAAOP,OAEjC,OADAO,EAAO6C,QAAO,SAAAC,GAAK,OAAIA,EAAMhC,SAAWgC,EAAMjC,WAAamD,KAAiBjB,SAAQ,SAAAD,GAAK,OAAKc,GAAkBd,EAAMhC,YAC/GiD,EAA0BE,EAAgBL,EAAgB1D,GAEjE+D,EAAelB,SAAQ,SAAAD,GAAK,OAAKA,EAAMhC,SAAWgC,EAAMjC,WAAamD,MAkZnED,CAA0B5C,EAAUyC,EAAgB1D,IAC3CkB,EAAgB3B,SACzB2B,EAAgB2B,SAAQ,SAACc,EAASC,GAAY1C,EAAgB0C,GAASjC,EAAgBgC,MA9Y1D,SAAC7D,EAAQ4D,EAAgB1D,GAC1D,IAAIiE,EACFC,EACAnH,EACA0D,EAEA0D,EACAtD,EACAD,EAHAwD,EAAc,EAKhB,GAAKtE,EAAOP,OAAZ,CAcA,IAVA0E,EAAYjE,EAAgB0D,GAD5BS,EAAerE,EAAO6C,QAAO,SAAAC,GAAK,MAAmB,WAAfA,EAAMlC,MAAqBkC,EAAM/B,cAAgBS,QAG1Ee,MAAK,SAAUC,EAAGC,GAI7B,OAHWD,EAAEzB,YAAcyB,EAAE1B,UACpB2B,EAAE1B,YAAc0B,EAAE3B,aAK7BH,EAAM0D,EAAa5E,OACZ6E,EAAc3D,GAAOwD,GAK1B,IAJAC,EAAyBD,GAAcE,EAAa5E,OAAS6E,GAAgB,GAIxErH,EAAI,EAAG0D,EAAM0D,EAAa5E,OAAQxC,EAAI0D,EAAK1D,IAC9C8D,EAAcsD,EAAapH,GAAG8D,YAG9BoD,IADArD,EAAWY,KAAKE,IAAIwC,EAAyBC,EAAapH,GAAG6D,SAAUC,IAC9CsD,EAAapH,GAAG6D,SACzCuD,EAAapH,GAAG6D,SAAWA,EAEvBC,IAAgBD,GAAauD,EAAapH,GAAGsH,SAC/CF,EAAapH,GAAGsH,QAAS,EACzBD,KAKNtE,EAASA,EAAO6C,QAAO,SAAAC,GAAK,MAAoB,WAAfA,EAAMlC,MAAqBkC,EAAM/B,cAAgBS,KAA4B,WAAfsB,EAAMlC,QACrGwD,EAAyBD,EAAYnE,EAAOP,OAE5CO,EAAO+C,SAAQ,SAAAD,GAAK,OAAKA,EAAMhC,UAAYsD,MAiWvCI,CAAiCpD,EAAiBwC,EAAgB1D,KAG/DC,O,8BAmBP,OAPAA,KAAKI,MAAQ,GACbJ,KAAKc,QAAU,CACbE,SAAU,GACVC,gBAAiB,GACjBiB,SAAU,IAGLlC,U,63BC/bX,IAAMsE,EAAa,CAAC,OAAQ,QAC1BC,EAAc,SAIdC,EAAmB,SAAAC,GAAG,OAAKA,EAAIC,OAAO,GAAGC,cAAgBF,EAAIxB,MAAM,IACnE2B,EAAkB,SAAAC,GAAQ,MACwBA,EAAK5F,OAAS,GAAxD6F,EADkB,EAClBA,oBAAqBC,EADH,EACGA,iBAE3B,OAAI,YAAYC,KAAKF,KAAwB,YAAYE,KAAKD,IAKhEE,EAAsB,SAAAC,GACpB,OAAOA,EAAUC,MAAM,UAAU,GAAGA,MAAM,KAAKC,KAAI,SAAAhG,GAAG,OAAIA,GAAOA,EAAIiG,WAEvEC,EAAe,SAAA5F,GAEb,GAAa,UADbA,EAAOA,EAAK2F,QACS,OAAO3F,EAC5B,IAAKH,OAAOG,GAAO,OAAQA,EAE3B,GAAI6E,EAAYS,KAAKtF,GAAO,CAC1B,IAAI6F,EAAS7F,EAAKyF,MAAM,UAAU,GAAGA,MAAM,KAE3C,MAAO,CACLI,EAAO,GAAGF,OACVE,EAAO,GAAGF,QAId,OAAO3F,GAET8F,EAAc,SAAC1F,EAAO2F,GACpB,IACEC,EAEAhG,EADAiG,EAAYnB,EAAiBiB,GAE7BG,EAAyB,UAAdH,EAAwB,MAAQ,MAgB7C,OAdgB3F,EAAMsF,KAAI,SAAAvD,GAQxB,OAPA6D,EAAc7D,EAAK5C,MAAM,eAAiBuF,EAA8B,QAAboB,EAAqB,UAAY,SAE1FlG,EAD+B,SAA7BX,EAAmB8C,IAAoB,YAAYmD,KAAKU,GACnDT,EAAoBS,GAAa,GAEjC7D,EAAK5C,MAAM,MAAQ0G,EAAY,iBAAmB9D,EAAK5C,MAAMwG,IAAc,OAG7E,CACLzD,MAAOH,EAAK+D,EAAW,SACvB3D,IAAKJ,EAAK+D,EAAW,OACrBlG,YAKNmG,EAAe,SAACC,EAAM9D,EAAOC,GAC3B,IAAInF,EACFiJ,EAEF,IAAKjJ,EAAIkF,EAAMgE,EAAGlJ,EAAImF,EAAI+D,EAAGlJ,IAC3B,IAAKiJ,EAAI/D,EAAMiE,EAAGF,EAAI9D,EAAIgE,EAAGF,IAC3BD,EAAKhJ,GAAGiJ,IAAK,GAInBG,EAAkB,SAAApG,GAChB,IAAIqG,EAAS,EAAGC,EAAY,EAK5B,OAJAtG,EAAM8C,SAAQ,SAACf,GACbuE,EAAY7E,KAAKC,IAAIjC,MAAMsC,EAAK5C,MAAMoH,iBAAmB,EAAIxE,EAAK5C,MAAMoH,gBAAiBD,EAAW7G,MAAiC,EAA3BsC,EAAK5C,MAAMqH,cAAoB,GAAK,EAA+B,EAA3BzE,EAAK5C,MAAMqH,cAAoB,GACjLH,EAAS5E,KAAKC,IAAIjC,MAAMsC,EAAK5C,MAAMsH,cAAgB,EAAI1E,EAAK5C,MAAMsH,aAAcJ,EAAQ5G,MAA8B,EAAxBsC,EAAK5C,MAAMuH,WAAiB,GAAK,EAA4B,EAAxB3E,EAAK5C,MAAMuH,WAAiB,MAE1J,CACLL,SACAC,cAGAK,E,WAKJ,c,4FAAe,SACbzG,KAAK0G,Q,uDAiBL,OANA1G,KAAK2G,KAAO,IAAI/G,EAChBI,KAAKI,MAAQ,GACbJ,KAAKc,QAAU,CACb8F,QAAS,IAGJ5G,O,0BAcJ3B,EAAKN,GAGR,OAFAiC,KAAKI,MAAM/B,GAAON,EAEXiC,O,+BAYC3B,GACR,OAAO2B,KAAKI,MAAM/B,K,gCAYTA,GACT,OAAO2B,KAAKc,QAAQzC,K,8BAebwI,GACP,IAAI7H,EAAU6H,GAAY7G,KAAKI,MAAMpB,QAErCgB,KAAK8G,gBAAgB9H,GAClB+H,eAAe/H,GACfgI,iBACAC,0BAA0BjI,K,wCAeC,IAI5BkI,EAJaL,EAAe,uDAAJ,GACtB5H,EAAQ4H,EAAS5H,MACjB8F,EAA0C9F,EAA1C8F,iBAAkBD,EAAwB7F,EAAxB6F,oBACpBjE,EAASb,KAAKc,QAFZ,EAIsBoF,EAAgBW,EAASM,UAA/Cf,EAJA,EAIAA,UAAWD,EAJX,EAIWA,OAmBf,OAjBAnG,KAAKE,IAAI,YAAaiG,GAEtBe,EAAYlH,KAAKoH,uBAAuBrC,GACxClE,EAAO+F,QAAQS,IAAM,CACnBC,cAAeJ,EAAUI,cACzBC,cAAeL,EAAUK,eAE3B1G,EAAO2G,UAAYN,EAAUrH,OAE7BG,KAAKE,IAAI,YAAakG,GACtBc,EAAYlH,KAAKoH,uBAAuBtC,GACxCjE,EAAO+F,QAAQa,IAAM,CACnBH,cAAeJ,EAAUI,cACzBC,cAAeL,EAAUK,eAE3B1G,EAAO6G,UAAYR,EAAUrH,OAEtBG,O,+CAegC,IACnClD,EACF0D,EAEAmH,EACAC,EAEAC,EACAC,EARoBjI,EAAiB,uDAAR,OAG7BkI,EAAoBlI,EAAOsF,MAzNV,KA4NjBzD,EAAkB,CAAC,IAGnB4F,EAAgB,GAChBC,EAAgB,GA4BlB,IA1BAI,EAAWI,EAAkBrF,QAAO,SAAAC,GAClC,OAAIA,GAA0B,iBAAVA,IAAsBA,EAAMrD,SAC9CkB,EAAMmC,EAAMrD,OACK,MAAbqD,EAAM,IAAiC,MAAnBA,EAAMnC,EAAM,OAQxCoH,EAAWG,EAAkBrF,QAAO,SAAAhD,GAClC,SAAKA,IAELc,GAAOd,EAAO,IAAIsI,cAAcrI,QAAQ,QAAS,MAC7C2E,EAAWlD,QAAQZ,IAAQ,GAAK+D,EAAYS,KAAKxE,KAASjB,MAAMiB,QAInE4E,KAAI,SAAA1F,GAAI,OAAI4F,EAAa5F,MAE5Bc,EAAMoH,EAAStI,OACA,SAAXO,IACFW,EAAMR,KAAKiI,SAAS,cAGjBnL,EAAI,EAAGA,EAAI0D,EAAK1D,IACnB+K,EAAkBF,EAAS7K,IAAM6K,EAAS7K,GAAG6C,QAAQ,SAAU,IAAIwF,MAAM,KAAKzC,QAAO,SAAArF,GAAI,OAAIA,EAAKiC,UAAQ8F,KAAI,SAAA/H,GAAI,OAAIA,EAAKgI,WAAY,CAACvI,EAAI,EAAI,IAChJgL,EAAgBH,EAAS7K,EAAI,IAAM6K,EAAS7K,EAAI,GAAG6C,QAAQ,SAAU,IAAIwF,MAAM,KAAKzC,QAAO,SAAArF,GAAI,OAAIA,EAAKiC,UAAQ8F,KAAI,SAAA/H,GAAI,OAAIA,EAAKgI,WAAY,CAACvI,EAAI,EAAI,IAEtJ4E,EAAgBJ,KAAK,CACnBU,MAAOlF,EAAI,EACXmF,IAAKnF,EAAI,EACT4C,KAAMkI,EAAS9K,IAAM,SAIvByK,EAAczK,EAAI,GAAK+K,EACvBN,EAAczK,EAAI,GAAKgL,EACvBD,EAAejF,SAAQ,SAAAvF,GAAI,OAAKiK,EAAcjK,GAAQP,EAAI,KAC1DgL,EAAalF,SAAQ,SAAAvF,GAAI,OAAKiK,EAAcjK,GAAQP,EAAI,KACxDwK,EAAcxK,EAAI,GAAKA,EAAI,EAC3BwK,EAAcxK,EAAI,GAAKA,EAAI,EAG7B,MAAO,CACL+C,OAAQ6B,EACR4F,gBACAC,mB,qCAeYV,GACd,IAQEqB,EAGAC,EACAtG,EACAuG,EACAtL,EACAiJ,EACAvF,EAhBExB,EAAW6H,GAAY7G,KAAKI,MAAMpB,QACpCc,EAAQd,EAAQmI,UAAY,GAC5BP,EAAU5G,KAAKc,QAAQ8F,QACvByB,EAAerJ,EAAQC,MAAMoJ,cAAgB,MAC7CC,EAAS9K,OAAO+K,KAAK3B,EAAQS,IAAIE,eAAejI,OAChDkJ,EAAShL,OAAO+K,KAAK3B,EAAQa,IAAIF,eAAejI,OAChDwC,EAAiB,GACjB2G,EAAgB,GAEhBC,EAAa,CAAC,IACdC,EAAY,GAQd,IAAK7L,EAAI,EAAGA,GAAK0L,EAAQ1L,IACvB4L,EAAWpH,KAAK,IAElB,IAAKxE,EAAI,EAAG0D,EAAMV,EAAMR,OAAQxC,EAAI0D,EAAK1D,IACvCoL,EAAYpI,EAAMhD,GAAGmC,MAErB6C,EAAeR,KAAf,KACKxB,EAAMhD,GADX,CAEE8L,SAAUhC,EAAQS,IAAIC,cAAcY,EAAU3B,cAC9CsC,OAAQjC,EAAQS,IAAIC,cAAcY,EAAU1B,YAC5CsC,SAAUlC,EAAQa,IAAIH,cAAcY,EAAU7B,iBAC9C0C,OAAQnC,EAAQa,IAAIH,cAAcY,EAAU5B,kBAE9CzE,EAAOC,EAAehF,GACtB+I,EAAa6C,EAAY,CAAC1C,EAAGnE,EAAKiH,SAAU7C,EAAGpE,EAAK+G,UAAW,CAAC5C,EAAGnE,EAAKkH,OAAQ9C,EAAGpE,EAAKgH,SAQ1F,IALAJ,EAAgB3G,EAAeY,QAAO,SAAAsG,GAAa,OAAMA,EAAcF,WAAaE,EAAcJ,cAM3E,QAAjBP,EAAwB,CAC1B,IAAKvL,EAAI,EAAGA,EAAIwL,EAAQxL,IACtB,IAAKiJ,EAAI,EAAGA,EAAIyC,EAAQzC,IACjB2C,EAAW5L,GAAGiJ,IACjB4C,EAAUrH,KAAK,CAAC+F,IAAKvK,EAAG2K,IAAK1B,IAKnC,KAAO0C,EAAcnJ,QAAUqJ,EAAUrJ,QACvCuC,EAAO4G,EAAcQ,QACrBd,EAAOQ,EAAUM,QAEjBpH,EAAK+G,SAAWT,EAAKd,IACrBxF,EAAKiH,SAAWX,EAAKV,IACrB5F,EAAKgH,OAASV,EAAKd,IAAM,EACzBxF,EAAKkH,OAASZ,EAAKV,IAAM,EAI3B,GADAW,EAAY7G,KAAK2H,KAAKT,EAAcnJ,OAASkJ,GAC9B,CACb,KAAOJ,KACLpJ,EAAQC,MAAM8F,kBAAoB,QAClC6B,EAAQS,IAAIC,cAAcgB,EAAS,GAAKA,EAAS,EACjD1B,EAAQS,IAAIC,cAAcgB,EAAS,GAAKA,EAAS,EACjDA,IACAI,EAAWpH,KAAK,IAKlB,IAHAtC,EAAQC,MAAM8F,iBAAmB/F,EAAQC,MAAM8F,iBAAiBM,OAEhEsD,EAAY,GACP7L,EAAI,EAAGA,GAAKwL,EAAQxL,IACvB,IAAKiJ,EAAI,EAAGA,GAAKyC,EAAQzC,IAClB2C,EAAW5L,GAAGiJ,IACjB4C,EAAUrH,KAAK,CAAC+F,IAAKvK,EAAG2K,IAAK1B,IAInC,KAAO0C,EAAcnJ,QACnBuC,EAAO4G,EAAcQ,QACrBd,EAAOQ,EAAUM,QAEjBpH,EAAK+G,SAAWT,EAAKd,IACrBxF,EAAKiH,SAAWX,EAAKV,IACrB5F,EAAKgH,OAASV,EAAKd,IAAM,EACzBxF,EAAKkH,OAASZ,EAAKV,IAAM,GAOjC,OADAzH,KAAKc,QAAQgB,eAAiBA,EACvB9B,O,uCAeS,IAEdmJ,EAFc,EAC+BnJ,KAAKc,QAA9CgB,EADU,EACVA,eAAgB4F,EADN,EACMA,UAAWF,EADjB,EACiBA,UAE/B4B,EAAwB,EACxBC,EAAuB,EACrBrK,EAAYgB,KAAKI,MAAjBpB,QALY,EAM2DA,EAAQC,OAAS,GAAxFqK,EANY,EAMZA,aAAcC,EANF,EAMEA,WAAYC,EANd,EAMcA,WAAYC,EAN1B,EAM0BA,cAAeC,EANzC,EAMyCA,MAAOC,EANhD,EAMgDA,OAC9DC,EAAM,IAAIhK,EAkCZ,OAhCKL,OAAOmK,KACVA,GAAUJ,EAAeC,GAE3BJ,EAAcS,EAAI3J,QACfC,IAAI,SAAUwH,GACdxH,IAAI,QAASsF,EAAY1D,EAAgB,UACzC5B,IAAI,gBAAiBwJ,GAAS,QAC9BG,gBAEHnC,EAAU9E,SAAQ,SAACD,EAAOgB,GACxBhB,EAAMmH,gBAAkBX,EAAYxF,GACpC0F,GAAwBF,EAAYxF,GAAOhD,UAAY,KAGzDX,KAAK+J,2BAEAxK,OAAOoK,KACVA,GAAWH,EAAaC,GAE1BN,EAAcS,EAAI3J,QACfC,IAAI,SAAUsH,GACdtH,IAAI,QAASsF,EAAY1D,EAAgB,WACzC5B,IAAI,gBAAiByJ,GAAU,QAC/BE,gBAEHrC,EAAU5E,SAAQ,SAACD,EAAOgB,GACxBhB,EAAMmH,gBAAkBX,EAAYxF,GACpCyF,GAAyBD,EAAYxF,GAAOhD,UAAY,KAG1D3B,EAAQC,MAAMmK,sBAAwBA,EACtCpK,EAAQC,MAAMoK,qBAAuBA,EAC9BrJ,O,+CAaiB6G,GACpB,IAMFmD,EACAlN,EACA0D,EACAyJ,EAEAC,EACApB,EACAC,EAZAoB,IADYtD,GAAY7G,KAAKI,MAAMpB,SACQoL,oBAAsB,IAAI1H,QAAO,SAAA2H,GAAK,MAAI,YAAYrF,KAAKqF,EAAMpL,MAAM6F,sBAC/G,YAAYE,KAAKqF,EAAMpL,MAAM8F,qBAF9B,EAGuB/E,KAAKc,QAA5B4G,EAHA,EAGAA,UAAWd,EAHX,EAGWA,QACb0D,EAAkBtK,KAAKiI,SAAS,UAChCsC,EAAa,CAAC,GAUhB,IAAKJ,EAAgC7K,OACnC,OAAOU,KAGT,IAAKlD,EAAI,EAAG0D,EAAMkH,EAAUpI,OAAQxC,EAAI0D,EAAK1D,IAC3CyN,EAAWzN,GAAKyN,EAAWzN,EAAI,GAAK4K,EAAU5K,GAAGgN,gBAAgBnJ,SAwBnE,OArBAwJ,EAAgCvH,SAAQ,SAAAyH,GAEtCH,EAAoBjF,EAAoBoF,EAAMpL,MAAM6F,qBAAqB,GACzEgE,EAAWlC,EAAQa,IAAIH,cAAc+C,EAAMpL,MAAMoH,iBACjD0C,EAASnC,EAAQa,IAAIH,cAAc+C,EAAMpL,MAAMqH,eAE/C2D,EAAaM,EAAWxB,EAAS,GAAKwB,EAAWzB,EAAW,GAM5DkB,EC7dN,SAAyBhL,EAASwL,GAC5B,IAEFC,EAMA3N,EACA0D,EATI2G,EAAanI,EAAbmI,SACJuD,EAAW,EAEXC,EAAa,EAGbC,EAAyB,GACzBC,EAAsB,GAGtBlB,EAAS,EACPmB,EAAqBN,EAArBM,UAAWpB,EAAUc,EAAVd,MAYb,IAVFA,EAAQnK,OAAOmK,GAAS,GAAKA,EAE7BvC,EAASvE,SAAQ,SAAAyH,GAAK,OAAKV,EAASpI,KAAKC,IAAImI,GAASU,EAAMpL,MAAM0K,QAAU,MAK1Ee,GAHFI,GAAaA,EAIXF,GAA2BE,EAAY,IACvCH,EAAa,EACR7N,EAAI,EAAG0D,EAAM2G,EAAS7H,OAAQxC,EAAI0D,KACjCkK,EAAWI,EAAYpB,GADe5M,IAI1C4N,GAAYI,EACZF,GAA2BE,EAAY,IAMzC,IAHAH,EAAa7N,EACb2N,EAAYlJ,KAAK2H,KAAK1I,EAAMmK,GAErBF,KACLI,GAAuBlB,EAAS,IAIpC,MAAO,CACL7E,oBAAqB8F,EAAuBvF,OAC5CN,iBAAkB8F,EAAoBxF,QDmbnB0F,CAAeV,EALnB,CACXS,UAAWZ,EACXR,MAAOO,IAKTI,EAAMpL,MAAM6F,oBAAsBkF,EAAelF,oBACjDuF,EAAMpL,MAAM8F,iBAAmBiF,EAAejF,iBAE9CuF,EAAgBU,iBAAiBX,MAI5BrK,O,gDAUkB6G,GACrB,IAEFhF,EACArB,EACA1D,EAEAmN,EACAgB,EACAvB,EACAC,EACA3D,EACAC,EAXEjH,EAAU6H,GAAY7G,KAAKI,MAAMpB,QAAjC,EACyCgB,KAAKc,QAA9CgB,EADA,EACAA,eAAgB0F,EADhB,EACgBA,UAAWE,EAD3B,EAC2BA,UAD3B,EAKuD1I,EAAQC,MAA/DiM,EALA,EAKAA,aAAcC,EALd,EAKcA,WAAY7B,EAL1B,EAK0BA,aAAcE,EALxC,EAKwCA,WAO1C4B,EAAa,CAAC9B,GACd+B,EAAa,CAAC7B,GAEhB,IAAK1M,EAAI,EAAG0D,EAAMgH,EAAUlI,OAAQxC,EAAI0D,EAAK1D,IAC3CsO,EAAWtO,GAAKsO,EAAWtO,EAAI,GAAK0K,EAAU1K,GAAGgN,gBAAgBnJ,SAGnE,IAAK7D,EAAI,EAAG0D,EAAMkH,EAAUpI,OAAQxC,EAAI0D,EAAK1D,IAC3CuO,EAAWvO,GAAKuO,EAAWvO,EAAI,GAAK4K,EAAU5K,GAAGgN,gBAAgBnJ,SAqDnE,OAnDA3B,EAAQsM,OAAS,CACftF,EAAG,EACHC,EAAG,EACHyD,MAAOnK,MAAMP,EAAQC,MAAMyK,OAAS2B,EAAWA,EAAW/L,OAAS,GAAKN,EAAQC,MAAMyK,MACtFC,OAAQpK,MAAMP,EAAQC,MAAM0K,QAAUyB,EAAWA,EAAW9L,OAAS,GAAKN,EAAQC,MAAM0K,SAEzF3K,EAAQmI,UAAY,IAAIvE,SAAQ,SAACyH,EAAO1G,GAQvC,OAPA9B,EAAOC,EAAe6B,GACtBsG,EAAaoB,EAAWxJ,EAAKkH,OAAS,GAAKsC,EAAWxJ,EAAKiH,SAAW,GACtEmC,EAAcG,EAAWvJ,EAAKgH,OAAS,GAAKuC,EAAWvJ,EAAK+G,SAAW,GAEvEc,EAAQnK,OAAO8K,EAAMpL,MAAMyK,OAASO,GAAcI,EAAMpL,MAAMyK,MAC9DC,EAASpK,OAAO8K,EAAMpL,MAAM0K,QAAUsB,GAAeZ,EAAMpL,MAAM0K,OAEzDuB,GAAgBb,EAAMpL,MAAMsM,aACpC,IHxiBK,SGyiBHvF,EAAIqF,EAAWxJ,EAAKiH,SAAW,GAAMmB,EAAa,EAAMP,EAAQ,EAAI,MACtE,IHxiBE,MGyiBA1D,EAAIqF,EAAWxJ,EAAKkH,OAAS,GAAKW,EAAO,MAC3C,IHziBM,UG0iBJA,EAAQO,EACRjE,EAAIqF,EAAWxJ,EAAKiH,SAAW,GAAI,MACrC,QACE9C,EAAIqF,EAAWxJ,EAAKiH,SAAW,GAGjC,OAAQqC,GAAcd,EAAMpL,MAAMuM,WAClC,IHpjBK,SGqjBHvF,EAAImF,EAAWvJ,EAAK+G,SAAW,GAAMqC,EAAc,EAAMtB,EAAS,EAAI,MACxE,IHpjBE,MGqjBA1D,EAAImF,EAAWvJ,EAAKgH,OAAS,GAAKc,EAAQ,MAC5C,IHrjBM,UGsjBJA,EAASsB,EACThF,EAAImF,EAAWvJ,EAAK+G,SAAW,GAAI,MACrC,QACE3C,EAAImF,EAAWvJ,EAAK+G,SAAW,GAGjC5C,GAAK7G,EAAY0C,EAAK5C,MAAMqK,aAAczH,EAAK5C,MAAMwM,QAAS,GAC9DxF,GAAK9G,EAAY0C,EAAK5C,MAAMuK,WAAY3H,EAAK5C,MAAMwM,QAAS,GAE5DpB,EAAMiB,OAAS,CACbtF,IACAC,IACAyF,GAAI1F,EAAI0D,EACRiC,GAAI1F,EAAI0D,EACRD,QACAC,aAIG3J,U,gCAIL4L,EAAsB,WAAsC,IAArCC,EAAqC,uDAAxB,GAAIC,EAAoB,uCAC1DC,EAAeF,EAAW1G,MA1kBX,KA0kBqCzC,QAAO,SAAAC,GAAK,OAAIA,KAAWA,EAAM0C,UACvF2G,EAAoB,GACpBC,EAAU,EAmBZ,OAjBIF,EAAazM,SAAY,WAAW0F,KAAK6G,GAC3CE,EAAanJ,SAAQ,SAAAD,GACf2B,EAAWlD,QAAQuB,IAAU,GAAK,UAAUqC,KAAKrC,IAAU4B,EAAYS,KAAKrC,KAAWpD,MAAMoD,IAC/FqJ,GAAqBF,EAAgBG,GAASnC,gBAAgBnJ,SAAW,IACzEsL,KAEAD,GAAqBrJ,EAAQ,OAIjCmJ,EAAgBlJ,SAAQ,SAAAD,GAClBpD,MAAMoD,EAAMmH,gBAAgBnJ,YAEhCqL,GAAsBrJ,EAAMmH,gBAAgBnJ,SAAW,QAIpDqL,EAAkB3G,QAE3B6G,EAAkC,SAAClN,EAAS8G,GACtC,IAKFuE,EACAvN,EACAiJ,EACAvF,EACA2L,EACAC,EACAxD,EACAC,EACAC,EACAC,EAdEsD,EAAiBrN,EAAQC,MAC3BuI,EAAY1B,EAAKwG,UAAU,aAC3B5E,EAAY5B,EAAKwG,UAAU,aAC3B1F,EAAUd,EAAKwG,UAAU,WACvBvH,EAA0CsH,EAA1CtH,iBAAkBD,EAAwBuH,EAAxBvH,oBAetB,IAHA9F,EAAQC,MAAM8F,iBAAmB6G,EAAoB7G,EAAkByC,GACvExI,EAAQC,MAAM6F,oBAAsB8G,EAAoB9G,EAAqB4C,GAExE5K,EAAI,EAAG0D,GAAOxB,EAAQmI,UAAY,IAAI7H,OAAQxC,EAAI0D,EAAK1D,IAE1D,GADAuN,EAAQrL,EAAQmI,SAASrK,GACrBiC,EAAmBsL,GAAQ,CAG7B,GAFAA,EAAMpL,MAAM6F,oBAAsBuF,EAAMkC,gBAAgBzH,oBACxDuF,EAAMpL,MAAM8F,iBAAmBsF,EAAMkC,gBAAgBxH,iBACjDxF,MAAM8K,EAAMkC,gBAAgB7C,OAAQ,CAOtC,IANAZ,EAAWuB,EAAMpL,MAAMoH,gBACvB0C,EAASsB,EAAMpL,MAAMqH,cAErBwC,EAAWlC,EAAQa,IAAIH,cAAcwB,GACrCC,EAASnC,EAAQa,IAAIH,cAAcyB,GAE9BhD,EAAI+C,EAAUsD,EAAc,EAAGrG,EAAIgD,EAAQhD,IAC9CqG,GAAe1E,EAAU3B,GAAG+D,gBAAgBnJ,SAE9C0J,EAAMpL,MAAMyK,MAAQ0C,EAEtB,GAAI7M,MAAM8K,EAAMkC,gBAAgB5C,QAAS,CAOvC,IANAf,EAAWyB,EAAMpL,MAAMsH,aACvBsC,EAASwB,EAAMpL,MAAMuH,WAErBoC,EAAWhC,EAAQS,IAAIC,cAAcsB,GACrCC,EAASjC,EAAQS,IAAIC,cAAcuB,GAE9B9C,EAAI6C,EAAUuD,EAAc,EAAGpG,EAAI8C,EAAQ9C,IAC9CoG,GAAe3E,EAAUzB,GAAG+D,gBAAgBnJ,SAE9C0J,EAAMpL,MAAM0K,OAASwC,GAK3B,OAAOnN,GAGX,SAASwN,EAAmBxN,GAAoB,IAC1ClC,EACF0D,EAEA6J,EACAvE,EALiC2G,EAAW,uDAAH,EAGzCxN,EAAQD,EAAQC,MAIlB,GAAKD,GAAYA,EAAQC,MAAzB,CAsBA,IAlBKD,EAAQuN,kBACXvN,EAAQC,MAAMyK,MAAQnK,MAAMP,EAAQC,MAAMyK,OAAS,OAAS1K,EAAQC,MAAMyK,MAC1E1K,EAAQC,MAAM0K,OAASpK,MAAMP,EAAQC,MAAM0K,QAAU,OAAS3K,EAAQC,MAAM0K,OAE5E1K,EAAMqK,aAAenK,EAAYF,EAAMqK,aAAcrK,EAAMwM,QAAS,GACpExM,EAAMsK,WAAapK,EAAYF,EAAMsK,WAAYtK,EAAMwM,QAAS,GAChExM,EAAMuK,WAAarK,EAAYF,EAAMuK,WAAYvK,EAAMwM,QAAS,GAChExM,EAAMwK,cAAgBtK,EAAYF,EAAMwK,cAAexK,EAAMwM,QAAS,GAEtEzM,EAAQuN,gBAAkB,CACxBzH,oBAAqB9F,EAAQC,MAAM6F,oBACnCC,iBAAkB/F,EAAQC,MAAM8F,iBAChC2E,MAAO1K,EAAQC,MAAMyK,MACrBC,OAAQ3K,EAAQC,MAAM0K,SAI1B3K,EAAQoL,mBAAqB,GACxBtN,EAAI,EAAG0D,EAAOxB,EAAQmI,UAAYnI,EAAQmI,SAAS7H,OAASxC,EAAI0D,EAAK1D,IACxEuN,EAAQrL,EAAQmI,SAASrK,GACrBiC,EAAmBsL,KACjBzF,EAAgByF,GAClBrK,KAAK0M,QAAQrC,GAEbrL,EAAQoL,mBAAmB9I,KAAK+I,IActC,OATAvE,EAAO,IAAIW,GACNvG,IAAI,UAAWlB,GACjBkB,IAAI,SAAUF,MACd0M,UAECD,EAAQ,GACVzM,KAAKgL,iBAAiBkB,EAAgClN,EAAS8G,GAAO,GAGjE9G,G,0KE9sBH2N,E,WACJ,c,4FAAe,SACb3M,KAAKgL,iBAAmBwB,E,uDAGjBxN,GACP,OAAQD,EAAmBC,IAC3B,ILXiB,OKYjB,ILXa,OKYb,QAEE,OAAOgB,KAAKgL,iBAAiBhM,S,gCAU7B4N,EAAgB,SAAC5N,GACrB,IAAM6N,EAAQ,IAAIF,EACdG,EJpBU,SAAdC,EAAe3N,GACb,GAAKN,EAAiBsC,QAAjB,EAAgChC,KAAQ,GAAc,OAARA,EACjD,OAAOA,EAGT,GAAI8B,MAAMC,QAAQ/B,GAAM,CACtB,IAAItC,EACF0D,EACAwM,EAAM,GAER,IAAKlQ,EAAI,EAAG0D,EAAMpB,EAAIE,OAAQxC,EAAI0D,EAAK1D,IACrCkQ,EAAI1L,KAAKyL,EAAY3N,EAAItC,KAG3B,OAAOkQ,EACF,GAAmB,WAAf,EAAO5N,GAAkB,CAClC,IACEf,EADE4O,EAAW,GAGf,IAAK5O,KAAOe,EACV6N,EAAS5O,GAAO0O,EAAY3N,EAAIf,IAGlC,OAAO4O,GIHSF,CAAY/N,GAOhC,OAJA8N,EAAc1Q,MAAO,EJGK,SAA1B8Q,IAAkE,IAC5DpQ,EACF0D,EAFuB2M,EAAuC,uDAA5B,GAAIC,EAAwB,uDAAP,GAMzD,IAFAD,EAAS7B,OAAS8B,EAAe9B,OAE5BxO,EAAI,EAAG0D,GAAO2M,EAAShG,UAAY,IAAI7H,OAAQxC,EAAI0D,EAAK1D,IAC3DoQ,EAAwBC,EAAShG,SAASrK,GAAIsQ,EAAejG,SAASrK,IIR1EoQ,CAAwBlO,EADP6N,EAAMH,QAAQI,IAGxB9N,GClCT","file":"faber.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"faber\"] = factory();\n\telse\n\t\troot[\"faber\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const DISPLAY_GRID = 'grid',\n  DISPLAY_FLEX = 'flex',\n  CENTER = 'center',\n  START = 'start',\n  END = 'end',\n  STRETCH = 'stretch',\n  ATOMIC_DATA_TYPE = ['string', 'number', 'function', 'boolean', 'undefined'];\n\nexport {\n  DISPLAY_GRID,\n  DISPLAY_FLEX,\n  CENTER,\n  START,\n  END,\n  STRETCH,\n  ATOMIC_DATA_TYPE\n};\n","import { ATOMIC_DATA_TYPE } from './constants';\n\nlet UNDEF;\n\nconst getDisplayProperty = (domTree) => {\n    return domTree.style && domTree.style.display;\n  },\n  cloneObject = (arg) => {\n    if ((ATOMIC_DATA_TYPE.indexOf(typeof arg) > -1) || arg === null) {\n      return arg;\n    }\n\n    if (Array.isArray(arg)) {\n      let i,\n        len,\n        arr = [];\n\n      for (i = 0, len = arg.length; i < len; i++) {\n        arr.push(cloneObject(arg[i]));\n      }\n\n      return arr;\n    } else if (typeof arg === 'object') {\n      let cloneObj = {},\n        key;\n\n      for (key in arg) {\n        cloneObj[key] = cloneObject(arg[key]);\n      }\n\n      return cloneObj;\n    }\n  },\n  attachLayoutInformation = (baseTree = {}, calculatedTree = {}) => {\n    let i,\n      len;\n\n    baseTree.layout = calculatedTree.layout;\n\n    for (i = 0, len = (baseTree.children || []).length; i < len; i++) {\n      attachLayoutInformation(baseTree.children[i], calculatedTree.children[i]);\n    }\n  },\n  pluckNumber = function () {\n    var arg,\n      i,\n      l;\n\n    for (i = 0, l = arguments.length; i < l; i += 1) {\n      arg = arguments[i];\n      if (!arg && arg !== false && arg !== 0) {\n        continue;\n      } else if (isNaN(arg = Number(arg))) {\n        continue;\n      }\n      return arg;\n    }\n    return UNDEF;\n  };\n\nexport {\n  cloneObject,\n  attachLayoutInformation,\n  getDisplayProperty,\n  pluckNumber\n};\n","const getMultiplierOfFr = size => +size.replace(/fr/, ''),\n  /**\n   * Helper function to distribute extra space among all the flexible tracks.\n   */\n  _frSpaceDistributorHelper = (tracks, totalSpaceUsed, containerSize) => {\n    let freeSpace,\n      spacePerFrTrack,\n      eligibleTracks,\n      totalFrTrackRatio = 0;\n\n    if (!tracks.length) {\n      return;\n    }\n\n    tracks.forEach(track => (totalFrTrackRatio += track.multiplier));\n\n    freeSpace = containerSize - totalSpaceUsed;\n    spacePerFrTrack = freeSpace / totalFrTrackRatio;\n\n    eligibleTracks = tracks.filter(track => track.baseSize <= track.multiplier * spacePerFrTrack);\n\n    if (eligibleTracks.length < tracks.length) {\n      tracks.filter(track => track.baseSize > track.multiplier * spacePerFrTrack).forEach(track => (totalSpaceUsed += track.baseSize));\n      return _frSpaceDistributorHelper(eligibleTracks, totalSpaceUsed, containerSize);\n    } else {\n      eligibleTracks.forEach(track => (track.baseSize = track.multiplier * spacePerFrTrack));\n    }\n  },\n  /**\n   * Helper function to distribute extra space among all the intrinsic tracks.\n   */\n  _intrinsicSpaceDistributorHelper = (tracks, totalSpaceUsed, containerSize) => {\n    let freeSpace,\n      spacePerIntrinsicTrack,\n      i,\n      len,\n      frozenTrack = 0,\n      minMaxTracks,\n      growthLimit,\n      baseSize;\n\n    if (!tracks.length) {\n      return;\n    }\n    minMaxTracks = tracks.filter(track => track.type === 'minmax' && track.growthLimit !== Infinity);\n    freeSpace = containerSize - totalSpaceUsed;\n\n    minMaxTracks.sort(function (a, b) {\n      let gap1 = a.growthLimit - a.baseSize,\n        gap2 = b.growthLimit - b.baseSize;\n\n      return gap1 - gap2;\n    });\n\n    len = minMaxTracks.length;\n    while (frozenTrack < len && freeSpace) {\n      spacePerIntrinsicTrack = freeSpace / ((minMaxTracks.length - frozenTrack) || 1);\n      /**\n       * @todo: remove the frozen tracks.\n       */\n      for (i = 0, len = minMaxTracks.length; i < len; i++) {\n        growthLimit = minMaxTracks[i].growthLimit;\n\n        baseSize = Math.min(spacePerIntrinsicTrack + minMaxTracks[i].baseSize, growthLimit);\n        freeSpace -= (baseSize - minMaxTracks[i].baseSize);\n        minMaxTracks[i].baseSize = baseSize;\n\n        if (growthLimit === baseSize && !minMaxTracks[i].frozen) {\n          minMaxTracks[i].frozen = true;\n          frozenTrack++;\n        }\n      }\n    }\n\n    tracks = tracks.filter(track => (track.type === 'minmax' && track.growthLimit === Infinity) || track.type !== 'minmax');\n    spacePerIntrinsicTrack = freeSpace / tracks.length;\n\n    tracks.forEach(track => (track.baseSize += spacePerIntrinsicTrack));\n  };\n\n/**\n * TrackResolver implements the standard track solving algorithm of CSS grid.\n * Refer https://www.w3.org/TR/css-grid-1/#algo-track-sizing\n *\n * @class TrackResolver\n */\nclass TrackResolver {\n  constructor (tracks = [], items = [], containerSize = 600) {\n    this.clear();\n\n    this.set('tracks', tracks);\n    this.set('items', items);\n    this.set('containerSize', containerSize);\n    return this;\n  }\n\n  /**\n   * setter method to set props\n   *\n   * @param   {string} key\n   *          key represents the name by which the value is to be stored in props object.\n   * @param   {any} info\n   *          info is the information(can be anything) that has to be stored against the key.\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  set (key, info) {\n    this.props[key] = info;\n\n    switch (key) {\n    case 'tracks':\n      this._initTrackSize(); break;\n    case 'items':\n      this._initItems(); break;\n    case 'containerSize': \n      this.props[key] = isNaN(+info) ? 0 : +info;\n    }\n    return this;\n  }\n\n  /**\n   * Getter method to fetch the props\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {any}\n   *          alue corresponding to the key in props object\n   * @memberof TrackResolver\n   */\n  get (key) {\n    return this.props[key];\n  }\n\n  /**\n   * Initializes the tracks. Both rows and columns in grid are tracks in TrackResolver.\n   * Each track is assigned a baseSize and growthLimit. BaseSize is the minimum size that a track can take,\n   * while growthLimit is the max size.\n   *\n   * Terminology:\n   * FrTracks: Tracks which have a size definition in terms of fr(free space)\n   * Intrinsic Tracks: Tracks which have a size definition of auto.\n   *\n   * @param   {Array} _tracks\n   *          Array containing information about the tracks.\n   * @returns {Array}\n   *          Array of sanitized tracks. A sanitized track consists of the following information\n   *          {\n   *              type: minmax | fixed | flex | intrinsic\n   *                    minmax: track has size definition in minmax format\n   *                    fixed: a fixed numeric value is provided as size definition\n   *                    flex: size definition is provided in terms of fr\n   *                    intrinsic: auto size definition\n   *              multiplier: Prefix of fr(2 in case of 2fr). default 1.\n   *              baseSize: lower size limit of track.\n   *              growthLimit: upper size limit of track.\n   *          }\n   * @memberof TrackResolver\n   */\n  _initTrackSize (_tracks) {\n    let tracks = _tracks || this.props.tracks || [],\n      config = this._config,\n      trackAr = [{}],\n      i,\n      len,\n      size,\n      type,\n      multiplier,\n      baseSize,\n      growthLimit;\n\n    config.frTracks = [];\n    config.intrinsicTracks = [];\n\n    for (i = 1, len = tracks.length; i < len; i++) {\n      size = tracks[i].size;\n\n      multiplier = 1;\n      if (Array.isArray(size)) {\n        baseSize = +size[0] || 0;\n\n        if (size[1].indexOf('fr') > 0 || size[0].indexOf('fr') > 0) {\n          growthLimit = Infinity;\n          config.frTracks.push(i);\n          type = 'minmax';\n        } else if (size[1] === 'auto' || size[0] === 'auto') {\n          growthLimit = Infinity;\n          config.intrinsicTracks.push(i);\n          type = 'minmax';\n        } else if (!isNaN(+size[0]) && !isNaN(+size[1])) {\n          growthLimit = Math.max(+size[0], +size[1]);\n          baseSize = Math.min(+size[0], +size[1]);\n          config.intrinsicTracks.push(i);\n          type = 'minmax';\n        }\n      } else if (!isNaN(+size)) {\n        baseSize = growthLimit = +size;\n        type = 'fixed';\n      } else if (size.indexOf('fr') > 0) {\n        baseSize = 0;\n        growthLimit = Infinity;\n        config.frTracks.push(i);\n        type = 'flex';\n        multiplier = getMultiplierOfFr(size);\n      } else {\n        baseSize = 0;\n        growthLimit = Infinity;\n        type = 'intrinsic';\n        config.intrinsicTracks.push(i);\n      }\n\n      trackAr.push({\n        ...tracks[i],\n        type,\n        multiplier,\n        baseSize,\n        growthLimit\n      });\n    }\n\n    return (config.sanitizedTracks = trackAr);\n  }\n\n  /**\n   * The size of grid items are sanitized in this method. In case the items do not have a valid size, they\n   * take up size of the tracks\n   *\n   * @param   {Array} _items\n   *          Array of grid items\n   * @returns {Array}\n   *          Array of items where each item has valid size\n   * @memberof TrackResolver\n   */\n  _initItems (_items) {\n    let items = _items || this.props.items || [],\n      config = this._config,\n      sanitizedItems = [],\n      nonSpanningItemStartIndex,\n      item,\n      validItems = 0,\n      i,\n      len;\n\n    for (i = 0, len = items.length; i < len; i++) {\n      if (isNaN(items[i].start) || isNaN(items[i].end)) {\n        config.autoFlow.push(items[i]);\n        continue;\n      }\n      sanitizedItems.push({...items[i]});\n\n      item = sanitizedItems[validItems];\n      validItems++;\n\n      item.size = isNaN(item.size) ? this._getParentSize(item) : +item.size;\n    }\n\n    sanitizedItems.sort(function (a, b) {\n      let gap1 = a.end - a.start,\n        gap2 = b.end - b.start;\n\n      if (gap1 === gap2) {\n        return a.start - b.start;\n      } else { return gap1 - gap2; }\n    });\n\n    for (i = 0, nonSpanningItemStartIndex = len = sanitizedItems.length; i < len; i++) {\n      if (sanitizedItems[i].end - sanitizedItems[i].start > 1) {\n        nonSpanningItemStartIndex = i;\n        break;\n      }\n    }\n\n    this._config.nonSpanningItemStartIndex = nonSpanningItemStartIndex;\n\n    return (this._config.sanitizedItems = sanitizedItems);\n  }\n\n  /**\n   * If any grid item do not have a valid size, then it takes up the size of the track.\n   *\n   * @param   {Object} item\n   *          The item which do not have a proper size and will take up the size of the track.\n   * @returns {number}\n   *          size of the track(s) which will be assigned to the grid item.\n   * @memberof TrackResolver\n   */\n  _getParentSize (item) {\n    let { sanitizedTracks } = this._config,\n      parentTracks,\n      widthOfParentTracks = 0;\n\n    parentTracks = sanitizedTracks.filter(track => (track.start >= item.start && track.end <= item.end));\n\n    parentTracks.forEach(track => (widthOfParentTracks += track.baseSize));\n\n    return (widthOfParentTracks || 0);\n  }\n\n  /**\n   * resolveTracks method is called to resolve the tracks.\n   *\n   * Terminology:\n   * Non-spanning items - items which is contained in a single track.\n   * Spanning items -  items which is spread across multiple tracks.\n   *\n   * 1. At first all the non-spanning items are placed. The tracks containing non-spanning gets a minimum size.\n   * 2. Then the spanning items are placed. If total size of all the tracks over which the spanning items are spread is less than\n   *  the size of the spanning items, then the extra space required by the item is accomodated equally by the non-fixed tracks.\n   * 3. Afer all the items are placed, if any free space remains, they get distributed among the non-fixed tracks.\n   *\n   * @returns {Array}\n   *          Array of objects where each object is a track with resolved size.\n   * @memberof TrackResolver\n   */\n  resolveTracks () {\n    this._placeNonSpanningItems()\n      ._placeSpanningItems()\n      ._distributeFreeSpace();\n\n    return this._config.sanitizedTracks;\n  }\n\n  /**\n   * Placing a non-spanning item. After placing the item if the containing track has a non-fixed size, it is increased to\n   * accomodate the item.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  _placeNonSpanningItems () {\n    let { sanitizedItems, sanitizedTracks, nonSpanningItemStartIndex } = this._config,\n      nonSpanningItems = sanitizedItems.slice(0, nonSpanningItemStartIndex),\n      track,\n      trackIndex;\n\n    nonSpanningItems.forEach(item => {\n      trackIndex = item.start;\n      track = sanitizedTracks[trackIndex];\n\n      if (track.type !== 'fixed') {\n        track.baseSize = Math.max(track.baseSize, item.size);\n        track.growthLimit = Math.max(track.growthLimit, track.baseSize);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Place the non-spanning items. If the total size of all tracks on which the item is spread is less than\n   * the size of the item, then the extra size required is accomodated by equally increasing the size of\n   * all the non-fixed containing tracks.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  _placeSpanningItems () {\n    let { sanitizedItems, sanitizedTracks, nonSpanningItemStartIndex, frTracks } = this._config,\n      spanningItems = sanitizedItems.slice(nonSpanningItemStartIndex),\n      trackSizedp = [0],\n      sizeConsumed,\n      sizeLeft,\n      sizePerTrack,\n      availableTracks,\n      hasFrTrack,\n      i,\n      len;\n\n    if (!spanningItems.length) return this;\n\n    for (i = 1, len = sanitizedTracks.length; i < len; i++) {\n      trackSizedp[i] = trackSizedp[i - 1] + (sanitizedTracks[i].baseSize || 0);\n    }\n\n    spanningItems.forEach(item => {\n      sizeConsumed = trackSizedp[item.end - 1] - trackSizedp[item.start - 1];\n      sizeLeft = Math.max(0, item.size - sizeConsumed);\n\n      if (!sizeLeft) return;\n\n      for (i = item.start, hasFrTrack = false, availableTracks = 0; i < item.end; i++) {\n        if (frTracks.indexOf(i) >= 0) {\n          hasFrTrack = true;\n        }\n        if (sanitizedTracks[i].type !== 'fixed') {\n          availableTracks++;\n        }\n      }\n\n      if (!availableTracks || hasFrTrack) return;\n\n      sizePerTrack = sizeLeft / availableTracks;\n      for (i = item.start; i < item.end; i++) {\n        if (sanitizedTracks[i].type !== 'fixed') {\n          sanitizedTracks[i].baseSize += sizePerTrack;\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * After all the items are placed and if any free space remains, it is distributed among the tracks.\n   * Distribution strategy depends on the track configurations.\n   * If there are tracks with flexible size\n   * definition(fr), then all the free space is allocated to those tracks.\n   * If there are no tracks with flexible size definiton, then the free space is distributed\n   * evenly among the intrinsic tracks.\n   * If all the tracks are fixed(ie, have fixed size), then the free space is not distributed.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  _distributeFreeSpace () {\n    let { frTracks, intrinsicTracks, sanitizedTracks } = this._config,\n      { containerSize } = this.props,\n      totalSpaceUsed = 0;\n\n    sanitizedTracks.forEach(track => (totalSpaceUsed += (track.baseSize || 0)));\n\n    if (totalSpaceUsed < containerSize) {\n      if (frTracks.length) {\n        frTracks.forEach((trackId, index) => { frTracks[index] = sanitizedTracks[trackId]; });\n        frTracks.forEach(track => (totalSpaceUsed -= track.baseSize));\n        _frSpaceDistributorHelper(frTracks, totalSpaceUsed, containerSize);\n      } else if (intrinsicTracks.length) {\n        intrinsicTracks.forEach((trackId, index) => { intrinsicTracks[index] = sanitizedTracks[trackId]; });\n        _intrinsicSpaceDistributorHelper(intrinsicTracks, totalSpaceUsed, containerSize);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * clears the props and configuration of TrackResolver. This method is called before using\n   * TrackResolver with different set of input.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  clear () {\n    this.props = {};\n    this._config = {\n      frTracks: [],\n      intrinsicTracks: [],\n      autoFlow: []\n    };\n\n    return this;\n  }\n}\n\nexport default TrackResolver;\n","import { getDisplayProperty, pluckNumber } from '../utils';\nimport TrackResolver from './track-sizing';\nimport { CENTER, END, STRETCH } from '../utils/constants';\nimport { repeatResolver } from './helpers/repeatResolver';\n\nconst validSizes = ['auto', 'none'],\n  minmaxRegex = /minmax/,\n  // repeatFunctionRegex = /repeat\\(/g,\n  // templateSplitRegex = /\\s(\\[.*\\])*(\\(.*\\))*/g,\n  templateSplitRegex = ' ',\n  getUCFirstString = str => (str.charAt(0).toUpperCase() + str.slice(1)),\n  validNestedGrid = tree => {\n    let { gridTemplateColumns, gridTemplateRows } = tree.style || {};\n\n    if (/repeat\\(/g.test(gridTemplateColumns) || /repeat\\(/g.test(gridTemplateRows)) {\n      return false;\n    }\n    return true;\n  },\n  parseRepeatFunction = repeatStr => {\n    return repeatStr.split(/\\(|\\)/g)[1].split(',').map(arg => arg && arg.trim());\n  },\n  getCleanSize = size => {\n    size = size.trim();\n    if (size === 'auto') return size;\n    if (!isNaN(+size)) return +size;\n\n    if (minmaxRegex.test(size)) {\n      let sizeAr = size.split(/\\(|\\)/g)[1].split(',');\n\n      return [\n        sizeAr[0].trim(),\n        sizeAr[1].trim()\n      ];\n    }\n\n    return size;\n  },\n  getItemSize = (items, dimension) => {\n    let filteredItems,\n      templateCol,\n      parsedDim = getUCFirstString(dimension),\n      size,\n      trackDir = dimension === 'width' ? 'col' : 'row';\n\n    filteredItems = items.map(item => {\n      templateCol = item.style['gridTemplate' + getUCFirstString(trackDir === 'col' ? 'columns' : 'rows')];\n      if (getDisplayProperty(item) === 'grid' && /repeat\\(/g.test(templateCol)) {\n        size = parseRepeatFunction(templateCol)[1];\n      } else {\n        size = item.style['min' + parsedDim + 'Contribution'] || item.style[dimension] || 'auto';\n      }\n\n      return {\n        start: item[trackDir + 'Start'],\n        end: item[trackDir + 'End'],\n        size\n      };\n    });\n    return filteredItems;\n  },\n  updateMatrix = (grid, start, end) => {\n    let i,\n      j;\n\n    for (i = start.x; i < end.x; i++) {\n      for (j = start.y; j < end.y; j++) {\n        grid[i][j] = true;\n      }\n    }\n  },\n  getMaxRowColumn = items => {\n    let maxRow = 1, maxColumn = 1;\n    items.forEach((item) => {\n      maxColumn = Math.max(isNaN(item.style.gridColumnStart) ? 0 : item.style.gridColumnStart, maxColumn, isNaN(item.style.gridColumnEnd * 1 - 1) ? 0 : item.style.gridColumnEnd * 1 - 1);\n      maxRow = Math.max(isNaN(item.style.gridRowStart) ? 0 : item.style.gridRowStart, maxRow, isNaN(item.style.gridRowEnd * 1 - 1) ? 0 : item.style.gridRowEnd * 1 - 1);\n    });\n    return {\n      maxRow,\n      maxColumn\n    };\n  };\nclass Grid {\n  /**\n   * Creates an instance of Grid. Initializes the props and _config object.\n   * @memberof Grid\n   */\n  constructor () {\n    this.setup();\n  }\n\n  /**\n   * Initializes _config, props objects. Also initializes and stores a new instance of TrackResolver.\n   *\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  setup () {\n    this._tsa = new TrackResolver();\n    this.props = {};\n    this._config = {\n      mapping: {}\n    };\n\n    return this;\n  }\n\n  /**\n   * Setter method to set props.\n   *\n   * @param   {string} key\n   *          key represents the name by which the value is to be stored in props object.\n   * @param   {any} value\n   *          value is the information(can be anything) that has to be stored against the key.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  set (key, value) {\n    this.props[key] = value;\n\n    return this;\n  }\n\n  /**\n   * Getter method to fetch props.\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {any}\n   *          value corresponding to the key in props object\n   * @memberof Grid\n   */\n  getProps (key) {\n    return this.props[key];\n  }\n\n  /**\n   * Getter method to fetch config.\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {any}\n   *          alue corresponding to the key in _config object\n   * @memberof Grid\n   */\n  getConfig (key) {\n    return this._config[key];\n  }\n\n  /**\n   * compute method is called to calculate the layout. This is the driver API.\n   * 1. Tracks(rows and columns) are sanitized. Sanitization of tracks consists of going through the child nodes to get an overall estimate\n   *    regarding the number of tracks that are required.\n   * 2. Items(child nodes) are sanitized. Any item without any proper gridStart and gridEnd values gets sanitized here.\n   * 3. Track solving algrithm is run for both columns and rows to calculate the size each track will get.\n   * 4. Once tracks are resolved and all tracks have their size, all the grid items are assigned their width, height, x and y(when applicable)\n   *\n   * @param {Object} _domTree\n   *        Full node tree consisting of grid container and grid items.\n   * @memberof Grid\n   */\n  compute (_domTree) {\n    let domTree = _domTree || this.props.domTree;\n\n    this._sanitizeTracks(domTree)\n      ._sanitizeItems(domTree)\n      ._inflateTracks()\n      ._assignCoordinatesToCells(domTree);\n  }\n\n  /**\n   * Rows and columns are refered as tracks in css-grid terminology.\n   * Track sanitization is required to account for any changes in the number of tracks by considering the grid items.\n   * Items are iterated to check if all the times can be accomodated within the user-defined grid cells. If not, tracks will\n   * be increased.\n   *\n   * @param   {Object} [_domTree={}]\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _sanitizeTracks (_domTree = {}) {\n    let style = _domTree.style,\n      { gridTemplateRows, gridTemplateColumns } = style,\n      config = this._config,\n      trackInfo,\n      { maxColumn, maxRow } = getMaxRowColumn(_domTree.children);\n\n    this.set('maxTracks', maxRow);\n\n    trackInfo = this._fetchTrackInformation(gridTemplateRows);\n    config.mapping.row = {\n      nameToLineMap: trackInfo.nameToLineMap,\n      lineToNameMap: trackInfo.lineToNameMap\n    };\n    config.rowTracks = trackInfo.tracks;\n\n    this.set('maxTracks', maxColumn);\n    trackInfo = this._fetchTrackInformation(gridTemplateColumns);\n    config.mapping.col = {\n      nameToLineMap: trackInfo.nameToLineMap,\n      lineToNameMap: trackInfo.lineToNameMap\n    };\n    config.colTracks = trackInfo.tracks;\n\n    return this;\n  }\n\n  /**\n   * Any track is bounded by two lines, which are called grid lines. A grid line can have multiple names.\n   * To make calculations more easier, a map is maintained between line names and line numbers.\n   *\n   * @param   {string} [tracks='none']\n   *          gridTemplateRows or gridTemplateColumns(user provided values)\n   * @returns {Object}\n   *          tracks: Array of tracks where track has it's start, end and size(provided by user) specified\n   *          nameToLineMap: Object where key is the name and the value is the line number\n   *          lineToNameMap: Object where key is the number and the value is the name\n   * @memberof Grid\n   */\n  _fetchTrackInformation (tracks = 'none') {\n    let i,\n      len,\n      splittedTrackInfo = tracks.split(templateSplitRegex),\n      nameList,\n      sizeList,\n      sanitizedTracks = [{}],\n      startLineNames,\n      endLineNames,\n      nameToLineMap = {},\n      lineToNameMap = {};\n\n    nameList = splittedTrackInfo.filter(track => {\n      if (track && typeof track === 'string' && track.length) {\n        len = track.length;\n        if (track[0] === '[' && track[len - 1] === ']') {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n\n    sizeList = splittedTrackInfo.filter(size => {\n      if (!size) return false;\n\n      len = (size + '').toLowerCase().replace(/px|fr/, '');\n      if (validSizes.indexOf(len) >= 0 || minmaxRegex.test(len) || !isNaN(len)) {\n        return true;\n      }\n      return false;\n    }).map(size => getCleanSize(size));\n\n    len = sizeList.length;\n    if (tracks === 'none') {\n      len = this.getProps('maxTracks');\n    }\n\n    for (i = 0; i < len; i++) {\n      startLineNames = (nameList[i] && nameList[i].replace(/\\[|\\]/g, '').split(' ').filter(name => name.length).map(name => name.trim())) || [i + 1 + ''];\n      endLineNames = (nameList[i + 1] && nameList[i + 1].replace(/\\[|\\]/g, '').split(' ').filter(name => name.length).map(name => name.trim())) || [i + 2 + ''];\n\n      sanitizedTracks.push({\n        start: i + 1,\n        end: i + 2,\n        size: sizeList[i] || 'auto'\n      });\n\n      // A line can have multiple names but a name can only be assigned to a single line\n      lineToNameMap[i + 1] = startLineNames;\n      lineToNameMap[i + 2] = endLineNames;\n      startLineNames.forEach(name => (nameToLineMap[name] = i + 1));\n      endLineNames.forEach(name => (nameToLineMap[name] = i + 2));\n      nameToLineMap[i + 1] = i + 1;\n      nameToLineMap[i + 2] = i + 2;\n    }\n\n    return {\n      tracks: sanitizedTracks,\n      nameToLineMap,\n      lineToNameMap\n    };\n  }\n\n  /**\n   * Sanitization of grid items. The gridRowStart and gridColumnStart values are replaced by the line numbers. Also,\n   * if any item do not have any gridRowStart and/or gridColumnEnd values mentioned, they are placed accordingly in\n   * empty cells in rowwise or columnwise manner, based on the value of gridAutoFlow.\n   *\n   * @param   {Object} _domTree\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _sanitizeItems (_domTree) {\n    let domTree = (_domTree || this.props.domTree),\n      items = domTree.children || [],\n      mapping = this._config.mapping,\n      gridAutoFlow = domTree.style.gridAutoFlow || 'row',\n      rowNum = Object.keys(mapping.row.lineToNameMap).length,\n      colNum = Object.keys(mapping.col.lineToNameMap).length,\n      sanitizedItems = [],\n      autoFlowItems = [],\n      itemStyle,\n      gridMatrix = [[]],\n      freeCells = [],\n      cell,\n      item,\n      extraRows,\n      i,\n      j,\n      len;\n\n    for (i = 1; i <= colNum; i++) {\n      gridMatrix.push([]);\n    }\n    for (i = 0, len = items.length; i < len; i++) {\n      itemStyle = items[i].style;\n\n      sanitizedItems.push({\n        ...items[i],\n        rowStart: mapping.row.nameToLineMap[itemStyle.gridRowStart],\n        rowEnd: mapping.row.nameToLineMap[itemStyle.gridRowEnd],\n        colStart: mapping.col.nameToLineMap[itemStyle.gridColumnStart],\n        colEnd: mapping.col.nameToLineMap[itemStyle.gridColumnEnd]\n      });\n      item = sanitizedItems[i];\n      updateMatrix(gridMatrix, {x: item.colStart, y: item.rowStart}, {x: item.colEnd, y: item.rowEnd});\n    }\n\n    autoFlowItems = sanitizedItems.filter(sanitizedItem => (!sanitizedItem.colStart || !sanitizedItem.rowStart));\n\n    /**\n     * @todo: Scope to improve code here.\n     */\n    if (autoFlowItems) {\n      if (gridAutoFlow === 'row') {\n        for (i = 1; i < rowNum; i++) {\n          for (j = 1; j < colNum; j++) {\n            if (!gridMatrix[i][j]) {\n              freeCells.push({row: i, col: j});\n            }\n          }\n        }\n\n        while (autoFlowItems.length && freeCells.length) {\n          item = autoFlowItems.shift();\n          cell = freeCells.shift();\n\n          item.rowStart = cell.row;\n          item.colStart = cell.col;\n          item.rowEnd = cell.row + 1;\n          item.colEnd = cell.col + 1;\n        }\n\n        extraRows = Math.ceil(autoFlowItems.length / colNum);\n        if (extraRows) {\n          while (extraRows--) {\n            domTree.style.gridTemplateRows += 'auto ';\n            mapping.row.nameToLineMap[rowNum + 1] = rowNum + 1;\n            mapping.row.nameToLineMap[rowNum + 2] = rowNum + 2;\n            rowNum++;\n            gridMatrix.push([]);\n          }\n          domTree.style.gridTemplateRows = domTree.style.gridTemplateRows.trim();\n\n          freeCells = [];\n          for (i = 1; i <= rowNum; i++) {\n            for (j = 1; j <= colNum; j++) {\n              if (!gridMatrix[i][j]) {\n                freeCells.push({row: i, col: j});\n              }\n            }\n          }\n          while (autoFlowItems.length) {\n            item = autoFlowItems.shift();\n            cell = freeCells.shift();\n\n            item.rowStart = cell.row;\n            item.colStart = cell.col;\n            item.rowEnd = cell.row + 1;\n            item.colEnd = cell.col + 1;\n          }\n        }\n      }\n    }\n\n    this._config.sanitizedItems = sanitizedItems;\n    return this;\n  }\n\n  /**\n   * Track solving algorithm is used to calculate the size of each track. First the column tracks are resolved, then the\n   * row tracks. For track solving algorithm to run, it is important to resolve all the nested grids. Solving the nested\n   * grids allows to consider their min-content contribution while solving tracks of parent grid.\n   *\n   * An exception arises if a nested grid has repeat in either of the gridTemplateColumns or gridTemplateRows property.\n   * In that case, the nested grid is solved once the column tracks of the parent grid is solved.\n   *\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _inflateTracks () {\n    let { sanitizedItems, colTracks, rowTracks } = this._config,\n      sizedTracks,\n      minHeightContribution = 0,\n      minWidthContribution = 0,\n      { domTree } = this.props,\n      { paddingStart, paddingEnd, paddingTop, paddingBottom, width, height } = domTree.style || {},\n      tsa = new TrackResolver();\n\n    if (!isNaN(+width)) {\n      width -= (paddingStart + paddingEnd);\n    }\n    sizedTracks = tsa.clear()\n      .set('tracks', colTracks)\n      .set('items', getItemSize(sanitizedItems, 'width'))\n      .set('containerSize', width || 'auto')\n      .resolveTracks();\n\n    colTracks.forEach((track, index) => {\n      track.calculatedStyle = sizedTracks[index];\n      minWidthContribution += sizedTracks[index].baseSize || 0;\n    });\n\n    this._solveUnresolvedChildren();\n\n    if (!isNaN(+height)) {\n      height -= (paddingTop + paddingBottom);\n    }\n    sizedTracks = tsa.clear()\n      .set('tracks', rowTracks)\n      .set('items', getItemSize(sanitizedItems, 'height'))\n      .set('containerSize', height || 'auto')\n      .resolveTracks();\n\n    rowTracks.forEach((track, index) => {\n      track.calculatedStyle = sizedTracks[index];\n      minHeightContribution += sizedTracks[index].baseSize || 0;\n    });\n\n    domTree.style.minHeightContribution = minHeightContribution;\n    domTree.style.minWidthContribution = minWidthContribution;\n    return this;\n  }\n\n  /**\n   * The grid items which are also grid containers(nested grids) and has repeat() configuration in either of\n   * gridTenplateColumns or gridTemplateRows attribute are solved after the column tracks of the parents are solved.\n   *\n   * @param   {Object} _domTree\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _solveUnresolvedChildren (_domTree) {\n    let domTree = _domTree || this.props.domTree,\n      childrenWithRepeatConfiguration = (domTree.unResolvedChildren || []).filter(child => /repeat\\(/g.test(child.style.gridTemplateColumns)\n      || /repeat\\(/g.test(child.style.gridTemplateRows)),\n      { colTracks, mapping } = this._config,\n      parentReference = this.getProps('parent'),\n      colTrackDp = [0],\n      resolvedTracks,\n      i,\n      len,\n      trackWidth,\n      parentInfo,\n      parsedWidthOfItem,\n      colStart,\n      colEnd;\n\n    if (!childrenWithRepeatConfiguration.length) {\n      return this;\n    }\n\n    for (i = 1, len = colTracks.length; i < len; i++) {\n      colTrackDp[i] = colTrackDp[i - 1] + colTracks[i].calculatedStyle.baseSize;\n    }\n\n    childrenWithRepeatConfiguration.forEach(child => {\n      // if (repeatFunctionRegex.test(child.style.gridTemplateColumns)) {\n      parsedWidthOfItem = parseRepeatFunction(child.style.gridTemplateColumns)[1];\n      colStart = mapping.col.nameToLineMap[child.style.gridColumnStart];\n      colEnd = mapping.col.nameToLineMap[child.style.gridColumnEnd];\n\n      trackWidth = colTrackDp[colEnd - 1] - colTrackDp[colStart - 1];\n      parentInfo = {\n        itemWidth: parsedWidthOfItem,\n        width: trackWidth\n      };\n\n      resolvedTracks = repeatResolver(child, parentInfo);\n\n      child.style.gridTemplateColumns = resolvedTracks.gridTemplateColumns;\n      child.style.gridTemplateRows = resolvedTracks.gridTemplateRows;\n\n      parentReference.gridLayoutEngine(child);\n      // }\n    });\n\n    return this;\n  }\n\n  /**\n   * After the grid is resolved, the items and the container should receive their dimensions(width, height) and positions(x, y).\n   * This values are calculated after considering the justifyItem and alignItem attributes.\n   *\n   * @param {Object} _domTree\n   * @memberof Grid\n   */\n  _assignCoordinatesToCells (_domTree) {\n    let domTree = _domTree || this.props.domTree,\n      { sanitizedItems, rowTracks, colTracks } = this._config,\n      item,\n      len,\n      i,\n      { justifyItems, alignItems, paddingStart, paddingTop } = domTree.style,\n      trackWidth,\n      trackHeight,\n      width,\n      height,\n      x,\n      y,\n      rowTrackdp = [paddingStart],\n      colTrackdp = [paddingTop];\n\n    for (i = 1, len = rowTracks.length; i < len; i++) {\n      rowTrackdp[i] = rowTrackdp[i - 1] + rowTracks[i].calculatedStyle.baseSize;\n    }\n\n    for (i = 1, len = colTracks.length; i < len; i++) {\n      colTrackdp[i] = colTrackdp[i - 1] + colTracks[i].calculatedStyle.baseSize;\n    }\n    domTree.layout = {\n      x: 0,\n      y: 0,\n      width: isNaN(domTree.style.width) ? colTrackdp[colTrackdp.length - 1] : domTree.style.width,\n      height: isNaN(domTree.style.height) ? rowTrackdp[rowTrackdp.length - 1] : domTree.style.height\n    };\n    (domTree.children || []).forEach((child, index) => {\n      item = sanitizedItems[index];\n      trackWidth = colTrackdp[item.colEnd - 1] - colTrackdp[item.colStart - 1];\n      trackHeight = rowTrackdp[item.rowEnd - 1] - rowTrackdp[item.rowStart - 1];\n\n      width = isNaN(+child.style.width) ? trackWidth : +child.style.width;\n      height = isNaN(+child.style.height) ? trackHeight : +child.style.height;\n\n      switch (justifyItems || child.style.justifySelf) {\n      case CENTER:\n        x = colTrackdp[item.colStart - 1] + (trackWidth / 2) - (width / 2); break;\n      case END:\n        x = colTrackdp[item.colEnd - 1] - width; break;\n      case STRETCH:\n        width = trackWidth;\n        x = colTrackdp[item.colStart - 1]; break;\n      default:\n        x = colTrackdp[item.colStart - 1];\n      }\n\n      switch (alignItems || child.style.alignSelf) {\n      case CENTER:\n        y = rowTrackdp[item.rowStart - 1] + (trackHeight / 2) - (height / 2); break;\n      case END:\n        y = rowTrackdp[item.rowEnd - 1] - height; break;\n      case STRETCH:\n        height = trackHeight;\n        y = rowTrackdp[item.rowStart - 1]; break;\n      default:\n        y = rowTrackdp[item.rowStart - 1];\n      }\n\n      x += pluckNumber(item.style.paddingStart, item.style.padding, 0);\n      y += pluckNumber(item.style.paddingTop, item.style.padding, 0);\n\n      child.layout = {\n        x,\n        y,\n        x2: x + width,\n        y2: y + height,\n        width,\n        height\n      };\n    });\n\n    return this;\n  }\n}\n\nconst replaceWithAbsValue = (styleTrack = '', calculatedTrack) => {\n    let trackSplitAr = styleTrack.split(templateSplitRegex).filter(track => track && !!track.trim()),\n      trackWithAbsValue = '',\n      counter = 1;\n\n    if (trackSplitAr.length && !(/repeat\\(/.test(styleTrack))) {\n      trackSplitAr.forEach(track => {\n        if (validSizes.indexOf(track) > -1 || /[0-9]fr/.test(track) || minmaxRegex.test(track) || !isNaN(track)) {\n          trackWithAbsValue += calculatedTrack[counter].calculatedStyle.baseSize + ' ';\n          counter++;\n        } else {\n          trackWithAbsValue += track + ' ';\n        }\n      });\n    } else {\n      calculatedTrack.forEach(track => {\n        if (isNaN(track.calculatedStyle.baseSize)) return;\n\n        trackWithAbsValue += (track.calculatedStyle.baseSize + ' ');\n      });\n    }\n\n    return trackWithAbsValue.trim();\n  },\n  updateDomTreeWithResolvedValues = (domTree, grid) => {\n    let containerStyle = domTree.style,\n      rowTracks = grid.getConfig('rowTracks'),\n      colTracks = grid.getConfig('colTracks'),\n      mapping = grid.getConfig('mapping'),\n      { gridTemplateRows, gridTemplateColumns } = containerStyle,\n      child,\n      i,\n      j,\n      len,\n      rowTrackSum,\n      colTrackSum,\n      rowStart,\n      rowEnd,\n      colStart,\n      colEnd;\n\n    domTree.style.gridTemplateRows = replaceWithAbsValue(gridTemplateRows, rowTracks);\n    domTree.style.gridTemplateColumns = replaceWithAbsValue(gridTemplateColumns, colTracks);\n\n    for (i = 0, len = (domTree.children || []).length; i < len; i++) {\n      child = domTree.children[i];\n      if (getDisplayProperty(child)) {\n        child.style.gridTemplateColumns = child.userGivenStyles.gridTemplateColumns;\n        child.style.gridTemplateRows = child.userGivenStyles.gridTemplateRows;\n        if (isNaN(child.userGivenStyles.width)) {\n          colStart = child.style.gridColumnStart;\n          colEnd = child.style.gridColumnEnd;\n\n          colStart = mapping.col.nameToLineMap[colStart];\n          colEnd = mapping.col.nameToLineMap[colEnd];\n\n          for (j = colStart, colTrackSum = 0; j < colEnd; j++) {\n            colTrackSum += colTracks[j].calculatedStyle.baseSize;\n          }\n          child.style.width = colTrackSum;\n        }\n        if (isNaN(child.userGivenStyles.height)) {\n          rowStart = child.style.gridRowStart;\n          rowEnd = child.style.gridRowEnd;\n\n          rowStart = mapping.row.nameToLineMap[rowStart];\n          rowEnd = mapping.row.nameToLineMap[rowEnd];\n\n          for (j = rowStart, rowTrackSum = 0; j < rowEnd; j++) {\n            rowTrackSum += rowTracks[j].calculatedStyle.baseSize;\n          }\n          child.style.height = rowTrackSum;\n        }\n      }\n    }\n\n    return domTree;\n  };\n\nfunction computeGridLayout (domTree, count = 1) {\n  let i,\n    len,\n    style = domTree.style,\n    child,\n    grid;\n\n  if (!domTree || !domTree.style) {\n    return;\n  }\n\n  if (!domTree.userGivenStyles) {\n    domTree.style.width = isNaN(domTree.style.width) ? 'auto' : domTree.style.width;\n    domTree.style.height = isNaN(domTree.style.height) ? 'auto' : domTree.style.height;\n\n    style.paddingStart = pluckNumber(style.paddingStart, style.padding, 0);\n    style.paddingEnd = pluckNumber(style.paddingEnd, style.padding, 0);\n    style.paddingTop = pluckNumber(style.paddingTop, style.padding, 0);\n    style.paddingBottom = pluckNumber(style.paddingBottom, style.padding, 0);\n\n    domTree.userGivenStyles = {\n      gridTemplateColumns: domTree.style.gridTemplateColumns,\n      gridTemplateRows: domTree.style.gridTemplateRows,\n      width: domTree.style.width,\n      height: domTree.style.height\n    };\n  }\n\n  domTree.unResolvedChildren = [];\n  for (i = 0, len = (domTree.children && domTree.children.length); i < len; i++) {\n    child = domTree.children[i];\n    if (getDisplayProperty(child)) {\n      if (validNestedGrid(child)) {\n        this.compute(child);\n      } else {\n        domTree.unResolvedChildren.push(child);\n      }\n    }\n  }\n\n  grid = new Grid();\n  grid.set('domTree', domTree)\n    .set('parent', this)\n    .compute();\n\n  if (count < 2) {\n    this.gridLayoutEngine(updateDomTreeWithResolvedValues(domTree, grid), 2);\n  }\n\n  return domTree;\n}\n\nexport {\n  computeGridLayout\n};\n","/**\n * Resolve repeat configurations if provided in gridTemplateRows or gridTemplateColumns.\n * Based on the size provided by the parent, this method re-defines the gridTemplateRows and/or\n * gridTemplateColumns attributes of the grid container.\n *\n * @param   {Object} domTree\n *          Object representing the node. The value of gridTemplateColumns and gridTemplateRows are taken from the style\n *          object of node\n * @param   {Object} parentInfo\n *          Object containing the following properties\n *          {\n *            itemWidth: width of item\n *            width: width of track\n *          }\n * @returns {Object}\n *          {\n *            gridTemplateColumns: resolved gridTemplateColumns\n *            gridTemplateRows: resolved gridTemplateRows\n *          }\n */\nfunction repeatResolver (domTree, parentInfo) {\n  let { children } = domTree,\n    rowWidth = 0,\n    numOfRows,\n    itemInARow = 0,\n    // itemWidth,\n    repeatStyle = 'auto-fit',\n    newGridTemplateColumns = '',\n    newGridTemplateRows = '',\n    i,\n    len,\n    height = 0,\n    { itemWidth, width } = parentInfo;\n\n  width = isNaN(+width) ? 0 : +width;\n\n  children.forEach(child => (height = Math.max(height, +child.style.height || 0)));\n  // [repeatStyle, itemWidth] = parseRepeatFunction(gridTemplateColumns);\n  itemWidth = +itemWidth;\n\n  if (repeatStyle === 'auto-fit') {\n    rowWidth += itemWidth;\n    newGridTemplateColumns += (itemWidth + ' ');\n    itemInARow = 1;\n    for (i = 1, len = children.length; i < len; i++) {\n      if (rowWidth + itemWidth > width) {\n        break;\n      }\n      rowWidth += itemWidth;\n      newGridTemplateColumns += (itemWidth + ' ');\n    }\n\n    itemInARow = i;\n    numOfRows = Math.ceil(len / itemInARow);\n\n    while (numOfRows--) {\n      newGridTemplateRows += height + ' ';\n    }\n  }\n\n  return {\n    gridTemplateColumns: newGridTemplateColumns.trim(),\n    gridTemplateRows: newGridTemplateRows.trim()\n  };\n}\n\nexport {\n  repeatResolver\n};\n","import { getDisplayProperty, cloneObject, attachLayoutInformation } from './utils';\nimport { DISPLAY_GRID, DISPLAY_FLEX } from './utils/constants';\nimport { computeGridLayout } from './grid';\n\nclass LayoutEngine {\n  constructor () {\n    this.gridLayoutEngine = computeGridLayout;\n  }\n\n  compute (domTree) {\n    switch (getDisplayProperty(domTree)) {\n    case DISPLAY_GRID: return this.gridLayoutEngine(domTree);\n    case DISPLAY_FLEX: return this.gridLayoutEngine(domTree);\n    default:\n      // Probably throw unsupported error?\n      return this.gridLayoutEngine(domTree);\n    }\n  }\n}\n\n/**\n * Public API used externally to provide input to layout engine\n *\n * @param {Object} domTree Object containing the layout node information\n */\nconst computeLayout = (domTree) => {\n  const faber = new LayoutEngine();\n  let clonedDomTree = cloneObject(domTree),\n    calculatedTree;\n\n  clonedDomTree.root = true;\n  calculatedTree = faber.compute(clonedDomTree);\n  attachLayoutInformation(domTree, calculatedTree);\n\n  return domTree;\n};\n\nexport {\n  computeLayout\n};\n","import { computeLayout } from './faber';\n\nexport {\n  computeLayout\n};\n"],"sourceRoot":""}