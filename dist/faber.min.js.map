{"version":3,"sources":["webpack://faber/webpack/universalModuleDefinition","webpack://faber/webpack/bootstrap","webpack://faber/./src/utils/constants.js","webpack://faber/./src/utils/index.js","webpack://faber/./src/grid/track-sizing.js","webpack://faber/./src/grid/index.js","webpack://faber/./src/grid/helpers/repeatResolver.js","webpack://faber/./src/faber.js","webpack://faber/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ATOMIC_DATA_TYPE","getDisplayProperty","domTree","style","display","pluckNumber","arg","arguments","length","isNaN","Number","getMultiplierOfFr","size","replace","TrackResolver","tracks","items","containerSize","this","clear","set","info","props","_initTrackSize","_initItems","_tracks","len","type","multiplier","baseSize","growthLimit","config","_config","trackAr","frTracks","intrinsicTracks","Array","isArray","indexOf","Infinity","push","Math","max","min","sanitizedTracks","_items","nonSpanningItemStartIndex","item","sanitizedItems","validItems","start","end","autoFlow","_getParentSize","sort","a","b","gap1","gap2","widthOfParentTracks","filter","track","forEach","_placeNonSpanningItems","_placeSpanningItems","_distributeFreeSpace","trackIndex","slice","sizeConsumed","sizeLeft","sizePerTrack","availableTracks","hasFrTrack","spanningItems","trackSizedp","totalSpaceUsed","trackId","index","_frSpaceDistributorHelper","spacePerFrTrack","eligibleTracks","totalFrTrackRatio","freeSpace","spacePerIntrinsicTrack","minMaxTracks","frozenTrack","frozen","_intrinsicSpaceDistributorHelper","validSizes","minmaxRegex","templateSplitRegex","getUCFirstString","str","charAt","toUpperCase","validNestedGrid","tree","gridTemplateColumns","gridTemplateRows","test","parseRepeatFunction","repeatStr","split","map","trim","getCleanSize","sizeAr","getItemSize","dimension","templateCol","parsedDim","trackDir","updateMatrix","grid","j","x","y","resolveItemStyle","itemStyle","mapping","gridRowStart","gridRowEnd","gridColumnStart","gridColumnEnd","gridColumn","line","col","nameToLineMap","match","gridRow","row","getMaxRowColumn","maxRow","maxColumn","Grid","setup","_tsa","_domTree","_sanitizeTracks","_sanitizeItems","_inflateTracks","_assignCoordinatesToCells","trackInfo","children","_fetchTrackInformation","lineToNameMap","rowTracks","colTracks","nameList","sizeList","startLineNames","endLineNames","splittedTrackInfo","toLowerCase","getProps","cell","extraRows","gridAutoFlow","rowNum","keys","colNum","autoFlowItems","gridMatrix","freeCells","rowStart","rowEnd","colStart","colEnd","sanitizedItem","shift","ceil","sizedTracks","minHeightContribution","minWidthContribution","paddingStart","paddingEnd","paddingTop","paddingBottom","width","height","tsa","resolveTracks","calculatedStyle","_solveUnresolvedChildren","resolvedTracks","trackWidth","parsedWidthOfItem","childrenWithRepeatConfiguration","unResolvedChildren","child","parentReference","colTrackDp","parentInfo","numOfRows","rowWidth","itemInARow","newGridTemplateColumns","newGridTemplateRows","itemWidth","repeatResolver","gridLayoutEngine","trackHeight","justifyItems","alignItems","rowTrackdp","colTrackdp","layout","justifySelf","alignSelf","padding","x2","y2","replaceWithAbsValue","styleTrack","calculatedTrack","trackSplitAr","trackWithAbsValue","counter","updateDomTreeWithResolvedValues","rowTrackSum","colTrackSum","containerStyle","getConfig","userGivenStyles","computeGridLayout","count","compute","LayoutEngine","computeLayout","faber","clonedDomTree","cloneObject","arr","cloneObj","attachLayoutInformation","baseTree","calculatedTree"],"mappings":"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","file":"faber.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"faber\"] = factory();\n\telse\n\t\troot[\"faber\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const DISPLAY_GRID = 'grid',\n  DISPLAY_FLEX = 'flex',\n  CENTER = 'center',\n  START = 'start',\n  END = 'end',\n  STRETCH = 'stretch',\n  ATOMIC_DATA_TYPE = ['string', 'number', 'function', 'boolean', 'undefined'];\n\nexport {\n  DISPLAY_GRID,\n  DISPLAY_FLEX,\n  CENTER,\n  START,\n  END,\n  STRETCH,\n  ATOMIC_DATA_TYPE\n};\n","import { ATOMIC_DATA_TYPE } from './constants';\n\nlet UNDEF;\n\nconst getDisplayProperty = (domTree) => {\n    return domTree.style && domTree.style.display;\n  },\n  cloneObject = (arg) => {\n    if ((ATOMIC_DATA_TYPE.indexOf(typeof arg) > -1) || arg === null) {\n      return arg;\n    }\n\n    if (Array.isArray(arg)) {\n      let i,\n        len,\n        arr = [];\n\n      for (i = 0, len = arg.length; i < len; i++) {\n        arr.push(cloneObject(arg[i]));\n      }\n\n      return arr;\n    } else if (typeof arg === 'object') {\n      let cloneObj = {},\n        key;\n\n      for (key in arg) {\n        cloneObj[key] = cloneObject(arg[key]);\n      }\n\n      return cloneObj;\n    }\n  },\n  attachLayoutInformation = (baseTree = {}, calculatedTree = {}) => {\n    let i,\n      len;\n\n    baseTree.layout = calculatedTree.layout;\n\n    for (i = 0, len = (baseTree.children || []).length; i < len; i++) {\n      attachLayoutInformation(baseTree.children[i], calculatedTree.children[i]);\n    }\n  },\n  pluckNumber = function () {\n    var arg,\n      i,\n      l;\n\n    for (i = 0, l = arguments.length; i < l; i += 1) {\n      arg = arguments[i];\n      if (!arg && arg !== false && arg !== 0) {\n        continue;\n      } else if (isNaN(arg = Number(arg))) {\n        continue;\n      }\n      return arg;\n    }\n    return UNDEF;\n  };\n\nexport {\n  cloneObject,\n  attachLayoutInformation,\n  getDisplayProperty,\n  pluckNumber\n};\n","const getMultiplierOfFr = size => +size.replace(/fr/, ''),\n  /**\n   * Helper function to distribute extra space among all the flexible tracks.\n   */\n  _frSpaceDistributorHelper = (tracks, totalSpaceUsed, containerSize) => {\n    let freeSpace,\n      spacePerFrTrack,\n      eligibleTracks,\n      totalFrTrackRatio = 0;\n\n    if (!tracks.length) {\n      return;\n    }\n\n    tracks.forEach(track => (totalFrTrackRatio += track.multiplier));\n\n    freeSpace = containerSize - totalSpaceUsed;\n    spacePerFrTrack = freeSpace / totalFrTrackRatio;\n\n    eligibleTracks = tracks.filter(track => track.baseSize <= track.multiplier * spacePerFrTrack);\n\n    if (eligibleTracks.length < tracks.length) {\n      tracks.filter(track => track.baseSize > track.multiplier * spacePerFrTrack).forEach(track => (totalSpaceUsed += track.baseSize));\n      return _frSpaceDistributorHelper(eligibleTracks, totalSpaceUsed, containerSize);\n    } else {\n      eligibleTracks.forEach(track => (track.baseSize = track.multiplier * spacePerFrTrack));\n    }\n  },\n  /**\n   * Helper function to distribute extra space among all the intrinsic tracks.\n   */\n  _intrinsicSpaceDistributorHelper = (tracks, totalSpaceUsed, containerSize) => {\n    let freeSpace,\n      spacePerIntrinsicTrack,\n      i,\n      len,\n      frozenTrack = 0,\n      minMaxTracks,\n      growthLimit,\n      baseSize;\n\n    if (!tracks.length) {\n      return;\n    }\n    minMaxTracks = tracks.filter(track => track.type === 'minmax' && track.growthLimit !== Infinity);\n    freeSpace = containerSize - totalSpaceUsed;\n\n    minMaxTracks.sort(function (a, b) {\n      let gap1 = a.growthLimit - a.baseSize,\n        gap2 = b.growthLimit - b.baseSize;\n\n      return gap1 - gap2;\n    });\n\n    len = minMaxTracks.length;\n    while (frozenTrack < len && freeSpace) {\n      spacePerIntrinsicTrack = freeSpace / ((minMaxTracks.length - frozenTrack) || 1);\n      /**\n       * @todo: remove the frozen tracks.\n       */\n      for (i = 0, len = minMaxTracks.length; i < len; i++) {\n        growthLimit = minMaxTracks[i].growthLimit;\n\n        baseSize = Math.min(spacePerIntrinsicTrack + minMaxTracks[i].baseSize, growthLimit);\n        freeSpace -= (baseSize - minMaxTracks[i].baseSize);\n        minMaxTracks[i].baseSize = baseSize;\n\n        if (growthLimit === baseSize && !minMaxTracks[i].frozen) {\n          minMaxTracks[i].frozen = true;\n          frozenTrack++;\n        }\n      }\n    }\n\n    tracks = tracks.filter(track => (track.type === 'minmax' && track.growthLimit === Infinity) || track.type !== 'minmax');\n    spacePerIntrinsicTrack = freeSpace / tracks.length;\n\n    tracks.forEach(track => (track.baseSize += spacePerIntrinsicTrack));\n  };\n\n/**\n * TrackResolver implements the standard track solving algorithm of CSS grid.\n * Refer https://www.w3.org/TR/css-grid-1/#algo-track-sizing\n *\n * @class TrackResolver\n */\nclass TrackResolver {\n  constructor (tracks = [], items = [], containerSize = 600) {\n    this.clear();\n\n    this.set('tracks', tracks);\n    this.set('items', items);\n    this.set('containerSize', containerSize);\n    return this;\n  }\n\n  /**\n   * setter method to set props\n   *\n   * @param   {string} key\n   *          key represents the name by which the value is to be stored in props object.\n   * @param   {any} info\n   *          info is the information(can be anything) that has to be stored against the key.\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  set (key, info) {\n    this.props[key] = info;\n\n    switch (key) {\n    case 'tracks':\n      this._initTrackSize(); break;\n    case 'items':\n      this._initItems(); break;\n    case 'containerSize': \n      this.props[key] = isNaN(+info) ? 0 : +info;\n    }\n    return this;\n  }\n\n  /**\n   * Getter method to fetch the props\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {any}\n   *          alue corresponding to the key in props object\n   * @memberof TrackResolver\n   */\n  get (key) {\n    return this.props[key];\n  }\n\n  /**\n   * Initializes the tracks. Both rows and columns in grid are tracks in TrackResolver.\n   * Each track is assigned a baseSize and growthLimit. BaseSize is the minimum size that a track can take,\n   * while growthLimit is the max size.\n   *\n   * Terminology:\n   * FrTracks: Tracks which have a size definition in terms of fr(free space)\n   * Intrinsic Tracks: Tracks which have a size definition of auto.\n   *\n   * @param   {Array} _tracks\n   *          Array containing information about the tracks.\n   * @returns {Array}\n   *          Array of sanitized tracks. A sanitized track consists of the following information\n   *          {\n   *              type: minmax | fixed | flex | intrinsic\n   *                    minmax: track has size definition in minmax format\n   *                    fixed: a fixed numeric value is provided as size definition\n   *                    flex: size definition is provided in terms of fr\n   *                    intrinsic: auto size definition\n   *              multiplier: Prefix of fr(2 in case of 2fr). default 1.\n   *              baseSize: lower size limit of track.\n   *              growthLimit: upper size limit of track.\n   *          }\n   * @memberof TrackResolver\n   */\n  _initTrackSize (_tracks) {\n    let tracks = _tracks || this.props.tracks || [],\n      config = this._config,\n      trackAr = [{}],\n      i,\n      len,\n      size,\n      type,\n      multiplier,\n      baseSize,\n      growthLimit;\n\n    config.frTracks = [];\n    config.intrinsicTracks = [];\n\n    for (i = 1, len = tracks.length; i < len; i++) {\n      size = tracks[i].size;\n\n      multiplier = 1;\n      if (Array.isArray(size)) {\n        baseSize = +size[0] || 0;\n\n        if (size[1].indexOf('fr') > 0 || size[0].indexOf('fr') > 0) {\n          growthLimit = Infinity;\n          config.frTracks.push(i);\n          type = 'minmax';\n        } else if (size[1] === 'auto' || size[0] === 'auto') {\n          growthLimit = Infinity;\n          config.intrinsicTracks.push(i);\n          type = 'minmax';\n        } else if (!isNaN(+size[0]) && !isNaN(+size[1])) {\n          growthLimit = Math.max(+size[0], +size[1]);\n          baseSize = Math.min(+size[0], +size[1]);\n          config.intrinsicTracks.push(i);\n          type = 'minmax';\n        }\n      } else if (!isNaN(+size)) {\n        baseSize = growthLimit = +size;\n        type = 'fixed';\n      } else if (size.indexOf('fr') > 0) {\n        baseSize = 0;\n        growthLimit = Infinity;\n        config.frTracks.push(i);\n        type = 'flex';\n        multiplier = getMultiplierOfFr(size);\n      } else {\n        baseSize = 0;\n        growthLimit = Infinity;\n        type = 'intrinsic';\n        config.intrinsicTracks.push(i);\n      }\n\n      trackAr.push({\n        ...tracks[i],\n        type,\n        multiplier,\n        baseSize,\n        growthLimit\n      });\n    }\n\n    return (config.sanitizedTracks = trackAr);\n  }\n\n  /**\n   * The size of grid items are sanitized in this method. In case the items do not have a valid size, they\n   * take up size of the tracks\n   *\n   * @param   {Array} _items\n   *          Array of grid items\n   * @returns {Array}\n   *          Array of items where each item has valid size\n   * @memberof TrackResolver\n   */\n  _initItems (_items) {\n    let items = _items || this.props.items || [],\n      config = this._config,\n      sanitizedItems = [],\n      nonSpanningItemStartIndex,\n      item,\n      validItems = 0,\n      i,\n      len;\n\n    for (i = 0, len = items.length; i < len; i++) {\n      if (isNaN(items[i].start) || isNaN(items[i].end)) {\n        config.autoFlow.push(items[i]);\n        continue;\n      }\n      sanitizedItems.push({...items[i]});\n\n      item = sanitizedItems[validItems];\n      validItems++;\n\n      item.size = isNaN(item.size) ? this._getParentSize(item) : +item.size;\n    }\n\n    sanitizedItems.sort(function (a, b) {\n      let gap1 = a.end - a.start,\n        gap2 = b.end - b.start;\n\n      if (gap1 === gap2) {\n        return a.start - b.start;\n      } else { return gap1 - gap2; }\n    });\n\n    for (i = 0, nonSpanningItemStartIndex = len = sanitizedItems.length; i < len; i++) {\n      if (sanitizedItems[i].end - sanitizedItems[i].start > 1) {\n        nonSpanningItemStartIndex = i;\n        break;\n      }\n    }\n\n    this._config.nonSpanningItemStartIndex = nonSpanningItemStartIndex;\n\n    return (this._config.sanitizedItems = sanitizedItems);\n  }\n\n  /**\n   * If any grid item do not have a valid size, then it takes up the size of the track.\n   *\n   * @param   {Object} item\n   *          The item which do not have a proper size and will take up the size of the track.\n   * @returns {number}\n   *          size of the track(s) which will be assigned to the grid item.\n   * @memberof TrackResolver\n   */\n  _getParentSize (item) {\n    let { sanitizedTracks } = this._config,\n      parentTracks,\n      widthOfParentTracks = 0;\n\n    parentTracks = sanitizedTracks.filter(track => (track.start >= item.start && track.end <= item.end));\n\n    parentTracks.forEach(track => (widthOfParentTracks += track.baseSize));\n\n    return (widthOfParentTracks || 0);\n  }\n\n  /**\n   * resolveTracks method is called to resolve the tracks.\n   *\n   * Terminology:\n   * Non-spanning items - items which is contained in a single track.\n   * Spanning items -  items which is spread across multiple tracks.\n   *\n   * 1. At first all the non-spanning items are placed. The tracks containing non-spanning gets a minimum size.\n   * 2. Then the spanning items are placed. If total size of all the tracks over which the spanning items are spread is less than\n   *  the size of the spanning items, then the extra space required by the item is accomodated equally by the non-fixed tracks.\n   * 3. Afer all the items are placed, if any free space remains, they get distributed among the non-fixed tracks.\n   *\n   * @returns {Array}\n   *          Array of objects where each object is a track with resolved size.\n   * @memberof TrackResolver\n   */\n  resolveTracks () {\n    this._placeNonSpanningItems()\n      ._placeSpanningItems()\n      ._distributeFreeSpace();\n\n    return this._config.sanitizedTracks;\n  }\n\n  /**\n   * Placing a non-spanning item. After placing the item if the containing track has a non-fixed size, it is increased to\n   * accomodate the item.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  _placeNonSpanningItems () {\n    let { sanitizedItems, sanitizedTracks, nonSpanningItemStartIndex } = this._config,\n      nonSpanningItems = sanitizedItems.slice(0, nonSpanningItemStartIndex),\n      track,\n      trackIndex;\n\n    nonSpanningItems.forEach(item => {\n      trackIndex = item.start;\n      track = sanitizedTracks[trackIndex];\n\n      if (track.type !== 'fixed') {\n        track.baseSize = Math.max(track.baseSize, item.size);\n        track.growthLimit = Math.max(track.growthLimit, track.baseSize);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Place the non-spanning items. If the total size of all tracks on which the item is spread is less than\n   * the size of the item, then the extra size required is accomodated by equally increasing the size of\n   * all the non-fixed containing tracks.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  _placeSpanningItems () {\n    let { sanitizedItems, sanitizedTracks, nonSpanningItemStartIndex, frTracks } = this._config,\n      spanningItems = sanitizedItems.slice(nonSpanningItemStartIndex),\n      trackSizedp = [0],\n      sizeConsumed,\n      sizeLeft,\n      sizePerTrack,\n      availableTracks,\n      hasFrTrack,\n      i,\n      len;\n\n    if (!spanningItems.length) return this;\n\n    for (i = 1, len = sanitizedTracks.length; i < len; i++) {\n      trackSizedp[i] = trackSizedp[i - 1] + (sanitizedTracks[i].baseSize || 0);\n    }\n\n    spanningItems.forEach(item => {\n      sizeConsumed = trackSizedp[item.end - 1] - trackSizedp[item.start - 1];\n      sizeLeft = Math.max(0, item.size - sizeConsumed);\n\n      if (!sizeLeft) return;\n\n      for (i = item.start, hasFrTrack = false, availableTracks = 0; i < item.end; i++) {\n        if (frTracks.indexOf(i) >= 0) {\n          hasFrTrack = true;\n        }\n        if (sanitizedTracks[i].type !== 'fixed') {\n          availableTracks++;\n        }\n      }\n\n      if (!availableTracks || hasFrTrack) return;\n\n      sizePerTrack = sizeLeft / availableTracks;\n      for (i = item.start; i < item.end; i++) {\n        if (sanitizedTracks[i].type !== 'fixed') {\n          sanitizedTracks[i].baseSize += sizePerTrack;\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * After all the items are placed and if any free space remains, it is distributed among the tracks.\n   * Distribution strategy depends on the track configurations.\n   * If there are tracks with flexible size\n   * definition(fr), then all the free space is allocated to those tracks.\n   * If there are no tracks with flexible size definiton, then the free space is distributed\n   * evenly among the intrinsic tracks.\n   * If all the tracks are fixed(ie, have fixed size), then the free space is not distributed.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  _distributeFreeSpace () {\n    let { frTracks, intrinsicTracks, sanitizedTracks } = this._config,\n      { containerSize } = this.props,\n      totalSpaceUsed = 0;\n\n    sanitizedTracks.forEach(track => (totalSpaceUsed += (track.baseSize || 0)));\n\n    if (totalSpaceUsed < containerSize) {\n      if (frTracks.length) {\n        frTracks.forEach((trackId, index) => { frTracks[index] = sanitizedTracks[trackId]; });\n        frTracks.forEach(track => (totalSpaceUsed -= track.baseSize));\n        _frSpaceDistributorHelper(frTracks, totalSpaceUsed, containerSize);\n      } else if (intrinsicTracks.length) {\n        intrinsicTracks.forEach((trackId, index) => { intrinsicTracks[index] = sanitizedTracks[trackId]; });\n        _intrinsicSpaceDistributorHelper(intrinsicTracks, totalSpaceUsed, containerSize);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * clears the props and configuration of TrackResolver. This method is called before using\n   * TrackResolver with different set of input.\n   *\n   * @returns {TrackResolver}\n   *          Reference of the class instance.\n   * @memberof TrackResolver\n   */\n  clear () {\n    this.props = {};\n    this._config = {\n      frTracks: [],\n      intrinsicTracks: [],\n      autoFlow: []\n    };\n\n    return this;\n  }\n}\n\nexport default TrackResolver;\n","import { getDisplayProperty, pluckNumber } from '../utils';\nimport TrackResolver from './track-sizing';\nimport { CENTER, END, STRETCH } from '../utils/constants';\nimport { repeatResolver } from './helpers/repeatResolver';\n\nconst validSizes = ['auto', 'none'],\n  minmaxRegex = /minmax/,\n  // repeatFunctionRegex = /repeat\\(/g,\n  // templateSplitRegex = /\\s(\\[.*\\])*(\\(.*\\))*/g,\n  templateSplitRegex  = /(?:[^\\s[\\]()]+|\\[[^[\\]]*\\]|\\([^()]*\\))+/g,\n  getUCFirstString = str => (str.charAt(0).toUpperCase() + str.slice(1)),\n  validNestedGrid = tree => {\n    let { gridTemplateColumns, gridTemplateRows } = tree.style || {};\n\n    if (/repeat\\(/g.test(gridTemplateColumns) || /repeat\\(/g.test(gridTemplateRows)) {\n      return false;\n    }\n    return true;\n  },\n  parseRepeatFunction = repeatStr => {\n    return repeatStr.split(/\\(|\\)/g)[1].split(',').map(arg => arg && arg.trim());\n  },\n  getCleanSize = size => {\n    size = size.trim();\n    if (size === 'auto') return size;\n    if (!isNaN(+size)) return +size;\n\n    if (minmaxRegex.test(size)) {\n      let sizeAr = size.split(/\\(|\\)/g)[1].split(',');\n\n      return [\n        sizeAr[0].trim(),\n        sizeAr[1].trim()\n      ];\n    }\n\n    return size;\n  },\n  getItemSize = (items, dimension) => {\n    let filteredItems,\n      templateCol,\n      parsedDim = getUCFirstString(dimension),\n      size,\n      trackDir = dimension === 'width' ? 'col' : 'row';\n\n    filteredItems = items.map(item => {\n      templateCol = item.style['gridTemplate' + getUCFirstString(trackDir === 'col' ? 'columns' : 'rows')];\n      if (getDisplayProperty(item) === 'grid' && /repeat\\(/g.test(templateCol)) {\n        size = parseRepeatFunction(templateCol)[1];\n      } else {\n        size = item.style['min' + parsedDim + 'Contribution'] || item.style[dimension] || 'auto';\n      }\n\n      return {\n        start: item[trackDir + 'Start'],\n        end: item[trackDir + 'End'],\n        size\n      };\n    });\n    return filteredItems;\n  },\n  updateMatrix = (grid, start, end) => {\n    let i,\n      j;\n\n    for (i = start.x; i < end.x; i++) {\n      for (j = start.y; j < end.y; j++) {\n        grid[i][j] = true;\n      }\n    }\n  },\n  /**\n  * Converts gridColumn and gridRow attribute values into numeric grid lines.\n  * This function is added to extend support for gridColumn and gridRow properties\n  *\n  * @param   {object} itemStyle\n  *          itemStyle holds the user given style attributes.\n  * @param   {object} mapping\n  *          mapping hold the references from grid line names to grid line number\n  * @returns {object} resolvedItemStyle\n  *          returns resolvedItemStyle which contains numeric grid lines\n  */\n  resolveItemStyle = (itemStyle, mapping) => {\n    let {gridRowStart, gridRowEnd, gridColumnStart, gridColumnEnd} = itemStyle;\n    if(itemStyle.gridColumn){\n      [gridColumnStart, gridColumnEnd] = itemStyle.gridColumn.split(\"/\").map(line => line.trim());\n      gridColumnStart = mapping ? mapping.col.nameToLineMap[gridColumnStart] : 1;\n      if(/span\\s+\\d+/g.test(gridColumnEnd)){\n        gridColumnEnd = gridColumnStart + +gridColumnEnd.match(/span\\s+(\\d+)/)[1];\n      }\n      gridColumnEnd = mapping ? mapping.col.nameToLineMap[gridColumnEnd] : 1;\n    }\n    if(itemStyle.gridRow){\n      [gridRowStart, gridRowEnd] = itemStyle.gridRow.split(\"/\").map(line => line.trim());\n      gridRowStart = mapping ? mapping.row.nameToLineMap[gridRowStart] : 1;\n      if(/span\\s\\d+/g.test(gridRowEnd)){\n        gridRowEnd = gridRowStart + +gridRowEnd.match(/span\\s(\\d+)/)[1];\n      }\n      gridRowEnd = mapping ? mapping.row.nameToLineMap[gridRowEnd] : 1;\n    }\n    return {\n      gridRowStart,\n      gridRowEnd,\n      gridColumnStart,\n      gridColumnEnd\n    };\n  },\n  /**\n  * Extracts maximum number of tracklines required when gridTemplateRows / gridTemplateColumns value is 'none' or not given\n  *\n  * @param   {Array} items\n  *          items holds the list of grid container children.\n  * @returns {object} \n  *          returns maximum number of track lines required\n  */  \n  getMaxRowColumn = items => {\n    let maxRow = 1, maxColumn = 1, itemStyle;\n    items.forEach((item) => {\n      itemStyle = resolveItemStyle(item.style);\n      maxColumn = Math.max(isNaN(+itemStyle.gridColumnStart) ? 0 : +itemStyle.gridColumnStart, maxColumn, isNaN(+itemStyle.gridColumnEnd - 1) ? 0 : +itemStyle.gridColumnEnd - 1);\n      maxRow = Math.max(isNaN(+itemStyle.gridRowStart) ? 0 : +itemStyle.gridRowStart, maxRow, isNaN(+itemStyle.gridRowEnd - 1) ? 0 : +itemStyle.gridRowEnd - 1);\n    });\n    return {\n      maxRow,\n      maxColumn\n    };\n  };\nclass Grid {\n  /**\n   * Creates an instance of Grid. Initializes the props and _config object.\n   * @memberof Grid\n   */\n  constructor () {\n    this.setup();\n  }\n\n  /**\n   * Initializes _config, props objects. Also initializes and stores a new instance of TrackResolver.\n   *\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  setup () {\n    this._tsa = new TrackResolver();\n    this.props = {};\n    this._config = {\n      mapping: {}\n    };\n\n    return this;\n  }\n\n  /**\n   * Setter method to set props.\n   *\n   * @param   {string} key\n   *          key represents the name by which the value is to be stored in props object.\n   * @param   {any} value\n   *          value is the information(can be anything) that has to be stored against the key.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  set (key, value) {\n    this.props[key] = value;\n\n    return this;\n  }\n\n  /**\n   * Getter method to fetch props.\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {any}\n   *          value corresponding to the key in props object\n   * @memberof Grid\n   */\n  getProps (key) {\n    return this.props[key];\n  }\n\n  /**\n   * Getter method to fetch config.\n   *\n   * @param   {string} key\n   *          key of the value which has to be fetched.\n   * @returns {any}\n   *          alue corresponding to the key in _config object\n   * @memberof Grid\n   */\n  getConfig (key) {\n    return this._config[key];\n  }\n\n  /**\n   * compute method is called to calculate the layout. This is the driver API.\n   * 1. Tracks(rows and columns) are sanitized. Sanitization of tracks consists of going through the child nodes to get an overall estimate\n   *    regarding the number of tracks that are required.\n   * 2. Items(child nodes) are sanitized. Any item without any proper gridStart and gridEnd values gets sanitized here.\n   * 3. Track solving algrithm is run for both columns and rows to calculate the size each track will get.\n   * 4. Once tracks are resolved and all tracks have their size, all the grid items are assigned their width, height, x and y(when applicable)\n   *\n   * @param {Object} _domTree\n   *        Full node tree consisting of grid container and grid items.\n   * @memberof Grid\n   */\n  compute (_domTree) {\n    let domTree = _domTree || this.props.domTree;\n\n    this._sanitizeTracks(domTree)\n      ._sanitizeItems(domTree)\n      ._inflateTracks()\n      ._assignCoordinatesToCells(domTree);\n  }\n\n  /**\n   * Rows and columns are refered as tracks in css-grid terminology.\n   * Track sanitization is required to account for any changes in the number of tracks by considering the grid items.\n   * Items are iterated to check if all the times can be accomodated within the user-defined grid cells. If not, tracks will\n   * be increased.\n   *\n   * @param   {Object} [_domTree={}]\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _sanitizeTracks (_domTree = {}) {\n    let style = _domTree.style,\n      { gridTemplateRows, gridTemplateColumns } = style,\n      config = this._config,\n      trackInfo,\n      { maxColumn, maxRow } = getMaxRowColumn(_domTree.children);\n\n    this.set('maxTracks', maxRow);\n\n    trackInfo = this._fetchTrackInformation(gridTemplateRows);\n    config.mapping.row = {\n      nameToLineMap: trackInfo.nameToLineMap,\n      lineToNameMap: trackInfo.lineToNameMap\n    };\n    config.rowTracks = trackInfo.tracks;\n\n    this.set('maxTracks', maxColumn);\n    trackInfo = this._fetchTrackInformation(gridTemplateColumns);\n    config.mapping.col = {\n      nameToLineMap: trackInfo.nameToLineMap,\n      lineToNameMap: trackInfo.lineToNameMap\n    };\n    config.colTracks = trackInfo.tracks;\n\n    return this;\n  }\n\n  /**\n   * Any track is bounded by two lines, which are called grid lines. A grid line can have multiple names.\n   * To make calculations more easier, a map is maintained between line names and line numbers.\n   *\n   * @param   {string} [tracks='none']\n   *          gridTemplateRows or gridTemplateColumns(user provided values)\n   * @returns {Object}\n   *          tracks: Array of tracks where track has it's start, end and size(provided by user) specified\n   *          nameToLineMap: Object where key is the name and the value is the line number\n   *          lineToNameMap: Object where key is the number and the value is the name\n   * @memberof Grid\n   */\n  _fetchTrackInformation (tracks = 'none') {\n    let i,\n      len,\n      splittedTrackInfo = tracks.match(templateSplitRegex),\n      nameList,\n      sizeList,\n      sanitizedTracks = [{}],\n      startLineNames,\n      endLineNames,\n      nameToLineMap = {},\n      lineToNameMap = {};\n\n    nameList = splittedTrackInfo.filter(track => {\n      if (track && typeof track === 'string' && track.length) {\n        len = track.length;\n        if (track[0] === '[' && track[len - 1] === ']') {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n\n    sizeList = splittedTrackInfo.filter(size => {\n      if (!size) return false;\n\n      len = (size + '').toLowerCase().replace(/px|fr/, '');\n      if (validSizes.indexOf(len) >= 0 || minmaxRegex.test(len) || !isNaN(len)) {\n        return true;\n      }\n      return false;\n    }).map(size => getCleanSize(size));\n\n    len = sizeList.length;\n    if (tracks === 'none') {\n      len = this.getProps('maxTracks');\n    }\n\n    for (i = 0; i < len; i++) {\n      startLineNames = (nameList[i] && nameList[i].replace(/\\[|\\]/g, '').split(' ').filter(name => name.length).map(name => name.trim())) || [i + 1 + ''];\n      endLineNames = (nameList[i + 1] && nameList[i + 1].replace(/\\[|\\]/g, '').split(' ').filter(name => name.length).map(name => name.trim())) || [i + 2 + ''];\n\n      sanitizedTracks.push({\n        start: i + 1,\n        end: i + 2,\n        size: sizeList[i] || 'auto'\n      });\n\n      // A line can have multiple names but a name can only be assigned to a single line\n      lineToNameMap[i + 1] = startLineNames;\n      lineToNameMap[i + 2] = endLineNames;\n      startLineNames.forEach(name => (nameToLineMap[name] = i + 1));\n      endLineNames.forEach(name => (nameToLineMap[name] = i + 2));\n      nameToLineMap[i + 1] = i + 1;\n      nameToLineMap[i + 2] = i + 2;\n    }\n\n    return {\n      tracks: sanitizedTracks,\n      nameToLineMap,\n      lineToNameMap\n    };\n  }\n\n  /**\n   * Sanitization of grid items. The gridRowStart and gridColumnStart values are replaced by the line numbers. Also,\n   * if any item do not have any gridRowStart and/or gridColumnEnd values mentioned, they are placed accordingly in\n   * empty cells in rowwise or columnwise manner, based on the value of gridAutoFlow.\n   *\n   * @param   {Object} _domTree\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _sanitizeItems (_domTree) {\n    let domTree = (_domTree || this.props.domTree),\n      items = domTree.children || [],\n      mapping = this._config.mapping,\n      gridAutoFlow = domTree.style.gridAutoFlow || 'row',\n      rowNum = Object.keys(mapping.row.lineToNameMap).length,\n      colNum = Object.keys(mapping.col.lineToNameMap).length,\n      sanitizedItems = [],\n      autoFlowItems = [],\n      itemStyle,\n      gridMatrix = [[]],\n      freeCells = [],\n      cell,\n      item,\n      extraRows,\n      i,\n      j,\n      len;\n\n    for (i = 1; i <= rowNum; i++) {\n      gridMatrix.push([]);\n    }\n    for (i = 0, len = items.length; i < len; i++) {\n      itemStyle = resolveItemStyle(items[i].style, mapping);\n\n      sanitizedItems.push({\n        ...items[i],\n        rowStart: mapping.row.nameToLineMap[itemStyle.gridRowStart],\n        rowEnd: mapping.row.nameToLineMap[itemStyle.gridRowEnd],\n        colStart: mapping.col.nameToLineMap[itemStyle.gridColumnStart],\n        colEnd: mapping.col.nameToLineMap[itemStyle.gridColumnEnd]\n      });\n      item = sanitizedItems[i];\n      updateMatrix(gridMatrix, {x: item.rowStart, y: item.colStart}, {x: item.rowEnd, y: item.colEnd});\n    }\n\n    autoFlowItems = sanitizedItems.filter(sanitizedItem => (!sanitizedItem.colStart || !sanitizedItem.rowStart));\n\n    /**\n     * @todo: Scope to improve code here.\n     */\n    if (autoFlowItems) {\n      if (gridAutoFlow === 'row') {\n        for (i = 1; i < rowNum; i++) {\n          for (j = 1; j < colNum; j++) {\n            if (!gridMatrix[i][j]) {\n              freeCells.push({row: i, col: j});\n            }\n          }\n        }\n\n        while (autoFlowItems.length && freeCells.length) {\n          item = autoFlowItems.shift();\n          cell = freeCells.shift();\n\n          item.rowStart = cell.row;\n          item.colStart = cell.col;\n          item.rowEnd = cell.row + 1;\n          item.colEnd = cell.col + 1;\n        }\n\n        extraRows = Math.ceil(autoFlowItems.length / colNum);\n        if (extraRows) {\n          while (extraRows--) {\n            domTree.style.gridTemplateRows += 'auto ';\n            mapping.row.nameToLineMap[rowNum + 1] = rowNum + 1;\n            mapping.row.nameToLineMap[rowNum + 2] = rowNum + 2;\n            rowNum++;\n            gridMatrix.push([]);\n          }\n          domTree.style.gridTemplateRows = domTree.style.gridTemplateRows.trim();\n\n          freeCells = [];\n          for (i = 1; i <= rowNum; i++) {\n            for (j = 1; j <= colNum; j++) {\n              if (!gridMatrix[i][j]) {\n                freeCells.push({row: i, col: j});\n              }\n            }\n          }\n          while (autoFlowItems.length) {\n            item = autoFlowItems.shift();\n            cell = freeCells.shift();\n\n            item.rowStart = cell.row;\n            item.colStart = cell.col;\n            item.rowEnd = cell.row + 1;\n            item.colEnd = cell.col + 1;\n          }\n        }\n      }\n    }\n\n    this._config.sanitizedItems = sanitizedItems;\n    return this;\n  }\n\n  /**\n   * Track solving algorithm is used to calculate the size of each track. First the column tracks are resolved, then the\n   * row tracks. For track solving algorithm to run, it is important to resolve all the nested grids. Solving the nested\n   * grids allows to consider their min-content contribution while solving tracks of parent grid.\n   *\n   * An exception arises if a nested grid has repeat in either of the gridTemplateColumns or gridTemplateRows property.\n   * In that case, the nested grid is solved once the column tracks of the parent grid is solved.\n   *\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _inflateTracks () {\n    let { sanitizedItems, colTracks, rowTracks } = this._config,\n      sizedTracks,\n      minHeightContribution = 0,\n      minWidthContribution = 0,\n      { domTree } = this.props,\n      { paddingStart, paddingEnd, paddingTop, paddingBottom, width, height } = domTree.style || {},\n      tsa = new TrackResolver();\n\n    if (!isNaN(+width)) {\n      width -= (paddingStart + paddingEnd);\n    }\n    sizedTracks = tsa.clear()\n      .set('tracks', colTracks)\n      .set('items', getItemSize(sanitizedItems, 'width'))\n      .set('containerSize', width || 'auto')\n      .resolveTracks();\n\n    colTracks.forEach((track, index) => {\n      track.calculatedStyle = sizedTracks[index];\n      minWidthContribution += sizedTracks[index].baseSize || 0;\n    });\n\n    this._solveUnresolvedChildren();\n\n    if (!isNaN(+height)) {\n      height -= (paddingTop + paddingBottom);\n    }\n    sizedTracks = tsa.clear()\n      .set('tracks', rowTracks)\n      .set('items', getItemSize(sanitizedItems, 'height'))\n      .set('containerSize', height || 'auto')\n      .resolveTracks();\n\n    rowTracks.forEach((track, index) => {\n      track.calculatedStyle = sizedTracks[index];\n      minHeightContribution += sizedTracks[index].baseSize || 0;\n    });\n\n    domTree.style.minHeightContribution = minHeightContribution;\n    domTree.style.minWidthContribution = minWidthContribution;\n    return this;\n  }\n\n  /**\n   * The grid items which are also grid containers(nested grids) and has repeat() configuration in either of\n   * gridTenplateColumns or gridTemplateRows attribute are solved after the column tracks of the parents are solved.\n   *\n   * @param   {Object} _domTree\n   *          Full node tree consisting of grid container and grid items.\n   * @returns {Grid}\n   *          Reference of the class instance.\n   * @memberof Grid\n   */\n  _solveUnresolvedChildren (_domTree) {\n    let domTree = _domTree || this.props.domTree,\n      childrenWithRepeatConfiguration = (domTree.unResolvedChildren || []).filter(child => /repeat\\(/g.test(child.style.gridTemplateColumns)\n      || /repeat\\(/g.test(child.style.gridTemplateRows)),\n      { colTracks, mapping } = this._config,\n      parentReference = this.getProps('parent'),\n      colTrackDp = [0],\n      resolvedTracks,\n      i,\n      len,\n      trackWidth,\n      parentInfo,\n      parsedWidthOfItem,\n      colStart,\n      colEnd;\n\n    if (!childrenWithRepeatConfiguration.length) {\n      return this;\n    }\n\n    for (i = 1, len = colTracks.length; i < len; i++) {\n      colTrackDp[i] = colTrackDp[i - 1] + colTracks[i].calculatedStyle.baseSize;\n    }\n\n    childrenWithRepeatConfiguration.forEach(child => {\n      // if (repeatFunctionRegex.test(child.style.gridTemplateColumns)) {\n      parsedWidthOfItem = parseRepeatFunction(child.style.gridTemplateColumns)[1];\n      colStart = mapping.col.nameToLineMap[child.style.gridColumnStart];\n      colEnd = mapping.col.nameToLineMap[child.style.gridColumnEnd];\n\n      trackWidth = colTrackDp[colEnd - 1] - colTrackDp[colStart - 1];\n      parentInfo = {\n        itemWidth: parsedWidthOfItem,\n        width: trackWidth\n      };\n\n      resolvedTracks = repeatResolver(child, parentInfo);\n\n      child.style.gridTemplateColumns = resolvedTracks.gridTemplateColumns;\n      child.style.gridTemplateRows = resolvedTracks.gridTemplateRows;\n\n      parentReference.gridLayoutEngine(child);\n      // }\n    });\n\n    return this;\n  }\n\n  /**\n   * After the grid is resolved, the items and the container should receive their dimensions(width, height) and positions(x, y).\n   * This values are calculated after considering the justifyItem and alignItem attributes.\n   *\n   * @param {Object} _domTree\n   * @memberof Grid\n   */\n  _assignCoordinatesToCells (_domTree) {\n    let domTree = _domTree || this.props.domTree,\n      { sanitizedItems, rowTracks, colTracks } = this._config,\n      item,\n      len,\n      i,\n      { justifyItems, alignItems, paddingStart, paddingTop } = domTree.style,\n      trackWidth,\n      trackHeight,\n      width,\n      height,\n      x,\n      y,\n      rowTrackdp = [paddingStart],\n      colTrackdp = [paddingTop];\n\n    for (i = 1, len = rowTracks.length; i < len; i++) {\n      rowTrackdp[i] = rowTrackdp[i - 1] + rowTracks[i].calculatedStyle.baseSize;\n    }\n\n    for (i = 1, len = colTracks.length; i < len; i++) {\n      colTrackdp[i] = colTrackdp[i - 1] + colTracks[i].calculatedStyle.baseSize;\n    }\n    domTree.layout = {\n      x: 0,\n      y: 0,\n      width: isNaN(domTree.style.width) ? colTrackdp[colTrackdp.length - 1] : domTree.style.width,\n      height: isNaN(domTree.style.height) ? rowTrackdp[rowTrackdp.length - 1] : domTree.style.height\n    };\n    (domTree.children || []).forEach((child, index) => {\n      item = sanitizedItems[index];\n      trackWidth = colTrackdp[item.colEnd - 1] - colTrackdp[item.colStart - 1];\n      trackHeight = rowTrackdp[item.rowEnd - 1] - rowTrackdp[item.rowStart - 1];\n\n      width = isNaN(+child.style.width) ? trackWidth : +child.style.width;\n      height = isNaN(+child.style.height) ? trackHeight : +child.style.height;\n\n      switch (justifyItems || child.style.justifySelf) {\n      case CENTER:\n        x = colTrackdp[item.colStart - 1] + (trackWidth / 2) - (width / 2); break;\n      case END:\n        x = colTrackdp[item.colEnd - 1] - width; break;\n      case STRETCH:\n        width = trackWidth;\n        x = colTrackdp[item.colStart - 1]; break;\n      default:\n        x = colTrackdp[item.colStart - 1];\n      }\n\n      switch (alignItems || child.style.alignSelf) {\n      case CENTER:\n        y = rowTrackdp[item.rowStart - 1] + (trackHeight / 2) - (height / 2); break;\n      case END:\n        y = rowTrackdp[item.rowEnd - 1] - height; break;\n      case STRETCH:\n        height = trackHeight;\n        y = rowTrackdp[item.rowStart - 1]; break;\n      default:\n        y = rowTrackdp[item.rowStart - 1];\n      }\n\n      x += pluckNumber(item.style.paddingStart, item.style.padding, 0);\n      y += pluckNumber(item.style.paddingTop, item.style.padding, 0);\n\n      child.layout = {\n        x,\n        y,\n        x2: x + width,\n        y2: y + height,\n        width,\n        height\n      };\n    });\n\n    return this;\n  }\n}\n\nconst replaceWithAbsValue = (styleTrack = '', calculatedTrack) => {\n    let trackSplitAr = (styleTrack.match(templateSplitRegex) || []).filter(track => track && !!track.trim()),\n      trackWithAbsValue = '',\n      counter = 1;\n\n    if (trackSplitAr.length && !(/repeat\\(/.test(styleTrack))) {\n      trackSplitAr.forEach(track => {\n        if (validSizes.indexOf(track) > -1 || /[0-9]fr/.test(track) || minmaxRegex.test(track) || !isNaN(track)) {\n          trackWithAbsValue += calculatedTrack[counter].calculatedStyle.baseSize + ' ';\n          counter++;\n        } else {\n          trackWithAbsValue += track + ' ';\n        }\n      });\n    } else {\n      calculatedTrack.forEach(track => {\n        if (isNaN(track.calculatedStyle.baseSize)) return;\n\n        trackWithAbsValue += (track.calculatedStyle.baseSize + ' ');\n      });\n    }\n\n    return trackWithAbsValue.trim();\n  },\n  updateDomTreeWithResolvedValues = (domTree, grid) => {\n    let containerStyle = domTree.style,\n      rowTracks = grid.getConfig('rowTracks'),\n      colTracks = grid.getConfig('colTracks'),\n      mapping = grid.getConfig('mapping'),\n      { gridTemplateRows, gridTemplateColumns } = containerStyle,\n      child,\n      i,\n      j,\n      len,\n      rowTrackSum,\n      colTrackSum,\n      rowStart,\n      rowEnd,\n      colStart,\n      colEnd;\n\n    domTree.style.gridTemplateRows = replaceWithAbsValue(gridTemplateRows, rowTracks);\n    domTree.style.gridTemplateColumns = replaceWithAbsValue(gridTemplateColumns, colTracks);\n\n    for (i = 0, len = (domTree.children || []).length; i < len; i++) {\n      child = domTree.children[i];\n      if (getDisplayProperty(child)) {\n        child.style.gridTemplateColumns = child.userGivenStyles.gridTemplateColumns;\n        child.style.gridTemplateRows = child.userGivenStyles.gridTemplateRows;\n        if (isNaN(child.userGivenStyles.width)) {\n          colStart = child.style.gridColumnStart;\n          colEnd = child.style.gridColumnEnd;\n\n          colStart = mapping.col.nameToLineMap[colStart];\n          colEnd = mapping.col.nameToLineMap[colEnd];\n\n          for (j = colStart, colTrackSum = 0; j < colEnd; j++) {\n            colTrackSum += colTracks[j].calculatedStyle.baseSize;\n          }\n          child.style.width = colTrackSum;\n        }\n        if (isNaN(child.userGivenStyles.height)) {\n          rowStart = child.style.gridRowStart;\n          rowEnd = child.style.gridRowEnd;\n\n          rowStart = mapping.row.nameToLineMap[rowStart];\n          rowEnd = mapping.row.nameToLineMap[rowEnd];\n\n          for (j = rowStart, rowTrackSum = 0; j < rowEnd; j++) {\n            rowTrackSum += rowTracks[j].calculatedStyle.baseSize;\n          }\n          child.style.height = rowTrackSum;\n        }\n      }\n    }\n\n    return domTree;\n  };\n\nfunction computeGridLayout (domTree, count = 1) {\n  let i,\n    len,\n    style = domTree.style,\n    child,\n    grid;\n\n  if (!domTree || !domTree.style) {\n    return;\n  }\n\n  if (!domTree.userGivenStyles) {\n    domTree.style.width = isNaN(domTree.style.width) ? 'auto' : domTree.style.width;\n    domTree.style.height = isNaN(domTree.style.height) ? 'auto' : domTree.style.height;\n\n    style.paddingStart = pluckNumber(style.paddingStart, style.padding, 0);\n    style.paddingEnd = pluckNumber(style.paddingEnd, style.padding, 0);\n    style.paddingTop = pluckNumber(style.paddingTop, style.padding, 0);\n    style.paddingBottom = pluckNumber(style.paddingBottom, style.padding, 0);\n\n    domTree.userGivenStyles = {\n      gridTemplateColumns: domTree.style.gridTemplateColumns,\n      gridTemplateRows: domTree.style.gridTemplateRows,\n      width: domTree.style.width,\n      height: domTree.style.height\n    };\n  }\n\n  domTree.unResolvedChildren = [];\n  for (i = 0, len = (domTree.children && domTree.children.length); i < len; i++) {\n    child = domTree.children[i];\n    if (getDisplayProperty(child)) {\n      if (validNestedGrid(child)) {\n        this.compute(child);\n      } else {\n        domTree.unResolvedChildren.push(child);\n      }\n    }\n  }\n\n  grid = new Grid();\n  grid.set('domTree', domTree)\n    .set('parent', this)\n    .compute();\n\n  if (count < 2) {\n    this.gridLayoutEngine(updateDomTreeWithResolvedValues(domTree, grid), 2);\n  }\n\n  return domTree;\n}\n\nexport {\n  computeGridLayout\n};\n","/**\n * Resolve repeat configurations if provided in gridTemplateRows or gridTemplateColumns.\n * Based on the size provided by the parent, this method re-defines the gridTemplateRows and/or\n * gridTemplateColumns attributes of the grid container.\n *\n * @param   {Object} domTree\n *          Object representing the node. The value of gridTemplateColumns and gridTemplateRows are taken from the style\n *          object of node\n * @param   {Object} parentInfo\n *          Object containing the following properties\n *          {\n *            itemWidth: width of item\n *            width: width of track\n *          }\n * @returns {Object}\n *          {\n *            gridTemplateColumns: resolved gridTemplateColumns\n *            gridTemplateRows: resolved gridTemplateRows\n *          }\n */\nfunction repeatResolver (domTree, parentInfo) {\n  let { children } = domTree,\n    rowWidth = 0,\n    numOfRows,\n    itemInARow = 0,\n    // itemWidth,\n    repeatStyle = 'auto-fit',\n    newGridTemplateColumns = '',\n    newGridTemplateRows = '',\n    i,\n    len,\n    height = 0,\n    { itemWidth, width } = parentInfo;\n\n  width = isNaN(+width) ? 0 : +width;\n\n  children.forEach(child => (height = Math.max(height, +child.style.height || 0)));\n  // [repeatStyle, itemWidth] = parseRepeatFunction(gridTemplateColumns);\n  itemWidth = +itemWidth;\n\n  if (repeatStyle === 'auto-fit') {\n    rowWidth += itemWidth;\n    newGridTemplateColumns += (itemWidth + ' ');\n    itemInARow = 1;\n    for (i = 1, len = children.length; i < len; i++) {\n      if (rowWidth + itemWidth > width) {\n        break;\n      }\n      rowWidth += itemWidth;\n      newGridTemplateColumns += (itemWidth + ' ');\n    }\n\n    itemInARow = i;\n    numOfRows = Math.ceil(len / itemInARow);\n\n    while (numOfRows--) {\n      newGridTemplateRows += height + ' ';\n    }\n  }\n\n  return {\n    gridTemplateColumns: newGridTemplateColumns.trim(),\n    gridTemplateRows: newGridTemplateRows.trim()\n  };\n}\n\nexport {\n  repeatResolver\n};\n","import { getDisplayProperty, cloneObject, attachLayoutInformation } from './utils';\nimport { DISPLAY_GRID, DISPLAY_FLEX } from './utils/constants';\nimport { computeGridLayout } from './grid';\n\nclass LayoutEngine {\n  constructor () {\n    this.gridLayoutEngine = computeGridLayout;\n  }\n\n  compute (domTree) {\n    switch (getDisplayProperty(domTree)) {\n    case DISPLAY_GRID: return this.gridLayoutEngine(domTree);\n    case DISPLAY_FLEX: return this.gridLayoutEngine(domTree);\n    default:\n      // Probably throw unsupported error?\n      return this.gridLayoutEngine(domTree);\n    }\n  }\n}\n\n/**\n * Public API used externally to provide input to layout engine\n *\n * @param {Object} domTree Object containing the layout node information\n */\nconst computeLayout = (domTree) => {\n  const faber = new LayoutEngine();\n  let clonedDomTree = cloneObject(domTree),\n    calculatedTree;\n\n  clonedDomTree.root = true;\n  calculatedTree = faber.compute(clonedDomTree);\n  attachLayoutInformation(domTree, calculatedTree);\n\n  return domTree;\n};\n\nexport {\n  computeLayout\n};\n","import { computeLayout } from './faber';\n\nexport {\n  computeLayout\n};\n"],"sourceRoot":""}